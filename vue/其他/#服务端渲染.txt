服务端渲染（SSR）指由服务端渲染HTML字符串，并作为响应返回给浏览器。然后浏览器将静态的HTML激活为能够交互的客户端应用。
一个服务端渲染的Vue应用，其大部分代码同时运行在服务端和客户端上，所以被认为是“通用的”。
*静态站点生成（SSG）一般用于页面数据对每个用户都是相同的情况。只需渲染一次，而不是每次请求进来都重新渲染，预渲染的页面生成后作为静态HTML文件被服务器托管（每当数据变化时，需要重新部署）。一个网站可以同时使用SSR和SSG为不同页面进行渲染。

使用原因：
#1、更快的首屏加载：纯客户端应用需要等到JS都下载并执行完成才显示，服务端渲染的首屏HTML可以跳过这个等待。
#2、更好的SEO：搜索引擎爬虫可以直接看到完全渲染的页面（现代的搜索引擎可以很好地对同步JS应用进行索引）。
权衡之处：
#1、开发限制：一些生命周期钩子只能在浏览器端使用。
#2、更多地构建配置和部署要求：服务端渲染的应用需要一个能让NodeJs服务器运行的环境。
#3、更高的服务器负载。

手动构建步骤
#1、通过createSSRApp创建应用及编写组件代码，这些代码在客户端和服务端是通用的（被称为通用代码）。
#2、服务端在请求函数中创建应用实例，然后通过renderToStrin（或其他renderToXXX/pipeToXXX方法）渲染成HTML字符串。
#3、客户端先创建应用实例，然后使用app.mount挂载至返回HTML中。
推荐方案：手动构建需要考虑很多细节，推荐Nuxt，Quasar，ViteSSR（偏底层）

说明
#1、Vue组件在SSR时编译产物有所区别，模板被编译为字符串拼接，而不是render函数，以此来提高渲染性能。
#2、SSR期间，响应性默认是禁用的因为没有用户交互和DOM更新。
#3、onMounted/onUpdated等生命周期钩子不会在SSR期间调用，避免在setup的根作用域中使用会产生副作用且需要被清理的代码（因为有可能在onUnmount中清理，但是SSR期间不会被调用），推荐在onMounted中注册，onUnmount中清理（这样只会在客户端中注册并在客户端中清理）。
#4、通用代码不能访问平台特有API（如window对象，document）,若要使用浏览器特定API可以移到如生命周期钩子中惰性访问；一些库也将平台特定实现封装在了通用API中方便使用。
#5、跨请求状态污染：使用全局单例维护状态，会导致每次请求使用共享的状态（仅在客户端上使用单例管理状态是没问题的）。推荐的方式是为每个请求创建全新实例管理状态，并通过app.provide注入。（Pinia状态管理库考虑了SSR，所以可以直接使用该库进行管理）。
#6、激活不匹配：预渲染的HTML不符合客户端期望，就会出现激活不匹配（可能导致的原因如错误的HTML被浏览器纠正，或是使用了随机值）。当遇到激活不匹配时Vue会尝试自动恢复，但这会导致一些性能的损失。推荐的方式是将可能产生不一致的代码作为客户端特定代码去使用（如放在onMount回调中）
*激活不匹配时会产生警告，使用元素的data-allow-mismatch属性可以消除警告。
#7、自定义指令：自定义指令一般用于直接操作DOM元素，所以SSR时会被忽略。如果仅仅想通过自定义指令为元素添加属性，则可以使用其中的getSSRProps钩子。
#8、Teleports：SSR过程中的teleports不会出现在主应用渲染出的字符串中，它们会暴露在渲染上下文ctx.teleports属性中，需要手动将其嵌入到正确位置中（如在body中放一个特殊div，然后把teleports内容放置其中）。大部分情况下推荐的方式是将teleports作为客户端特定代码去使用。