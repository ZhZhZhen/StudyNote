# JS引擎解析过程

### 解释阶段
>核心的JIT编译器将源码翻译成机器码运行
1. 读取代码，进行词法分析，将代码分解成词元
2. 对词元进行语法分析，将词元整理成语法树并做类型检查
3. 使用翻译器，将语法树转为字节码
4. 使用字节码翻译器，将字节码转为机器码
>现代浏览器采用即时编译，只在运行时用到哪一行才编译哪一行，并对结果进行缓存，一些浏览器省略了字节码的翻译步骤，直接将语法树转为机器码

### 预处理阶段
>执行代码前会进行预处理，预处理阶段已经创建了执行上下文以及对应的VO（VO在ES5之后被词法环境替代）
1. 分号补全。
2. 变量/函数提升：即在VO中添加属性（全局上下文为global，函数上下文为AO），顺序为：
    1. 扫描形参（如果在函数上下文中）并赋值函数调用时传递的参数值
    2. 扫描函数声明并指向对应函数体
    3. 扫描变量声明并设置undefined。
    >发生冲突时后者函数会覆盖前者，而后着变量声明会被忽略。


### 执行阶段：
1. 浏览器首次载入脚本时即创建全局执行上下文并压入执行栈，在全局预处理完成后开始全局执行；
2. 执行过程中遇到变量就对当前上下文VO的属性进行赋值操作，如果该变量未定义则相当于给全局执行上下文的VO创建属性，其中引用类型记录的是指向堆的地址；
3. 遇到函数则创建新执行上下文压入执行栈并进行新一轮预处理和执行操作，当执行完毕时，对应执行上下文弹出，然后将控制器交由栈顶执行上下文。


### 回收机制
- 标记清除：配合可达性从根对象进行分析，回收器首先给所有对象加上标记，之后再去除可达对象的标记，最后回收被标记的对象。效率较低，会造成内存碎片的问题。
- 引用计数：对象被引用时计数加一，不再引用时计数减一，当计数值为0则认为可以被回收。实现简单，但循环引用时会比较难处理。

实现上会配合采用其他优化手段：
- 标记整理：不同于标记清除，回收时使存活对象向内存一段移动，再清理边界外内存。缺点在于复制过程使得回收停顿加长。
- 分代收集：将回收区域分为新生代和老年代，减少每次检测遍历对象。多次未回收对象移至老年代，老年代的检测次数也会减少。新生代和老年代也会采用不同收集方法。
- 增量收集：将回收工作分为多个阶段进行，避免一次进行的明显延迟。
- 闲时收集：在CPU空闲时尝试收集。
