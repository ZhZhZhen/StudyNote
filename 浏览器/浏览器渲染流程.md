# 浏览器渲染流程
渲染发生在浏览器的渲染进程中，每个tab都有一个对应的渲染进程

### 1. 构建DOM树
> 使用HTML解析器将HTML字节流转为DOM结构。
1. 首先将字节流根据编码转为字符串
2. 然后通过分词器将字节流转为Token（分为TagToken和文本Token，TagToken包含StartTag和EndTag，对应标签的开闭）;
3. 最后将Token解析为DOM节点，并添加到DOM树中，类似于使用栈匹配括号表达式。

### 2. 计算样式
1. 构建CSSOM树：包括link引用的外部CSS，\<style>标签内的CSS，元素的内联CSS。
   * 通过类似构建DOM树的方式，经历字节流->字符串->Token->CSS节点->CSSOM树。
   * 可以通过document.styleSheets进行访问，具备了查询和修改的功能。
2. 转化样式表的属性，使其标准化，如使用rgb函数统一颜色描述，使用px统一尺寸描述。
3. 计算DOM树中每个节点的具体样式，会考虑到CSS的继承规则和层叠样式，最终计算结果保存在ComputedStyle结构内。

### 3、构建渲染树
从DOM树根开始遍历，忽略不可见节点（不可见的元素如\<head>，设置为display：none的元素），对可见节点应用合适的CSS规则，最终产出由Render Object组成的渲染树

### 4、布局（重排）
> 遍历渲染树，创建布局树
* 布局树包含每个可见节点的xy坐标（屏幕上的绝对坐标）和盒子模型的几何信息。
* 该树结构类似于DOM树，但是仅仅包含可见的内容有关的信息。如不包含不可见节点，并且多了一些伪类节点。
* *34步骤在不同的文章中被合并为同一个步骤，即布局步骤：遍历DOM树和ComputedStyle，忽略不可见节点，生成具有位置和几何信息的布局树。

### 5、分层
> 遍历布局树生成图层树
* 页面中的复杂效果如3D变换，z-index，为了方便实现，渲染引擎会为特定节点生成专用图层，并生成一颗对应的图层树。布局树并不是每个节点都包含图层，一个节点没有对应的层，则属于父节点图层。
* 当满足任一条件：a、拥有层叠上下文属性的元素。b、需要剪裁的元素（滚动条也会被单独提升为层），会被提升为一个单独的图层。

##### 分层概念
* RenderObject：记录每个节点渲染所需要的信息
* RenderLayer：决定渲染的层级顺序。当出现层叠上下文，半透明效果，RenderObject提升为RenderLayer，未提升的RenderObject从属于父级元素最近的RenderLayer。
* CompositingLayer（合成层）：使用GPU加速页面渲染。当3Dtransform，will-change设置为opacity，transform；使用包含opacity，transform的CSS过渡和动画；使用Canvas元素，RenderLayer会提升为合成层，未提升的RenderLayer从属于父级元素最近的合成层。
##### 合成层的作用
* 减少重绘重排，合成层的位图会交给GPU合成，一些动画效果也会使用GPU处理而不是重排重绘。
* 不引起整个页面的重排重绘。
* 合成层会消耗大量CPU和内存（每个合成层都有一个后端存储），不过动画只有在开始时才会提升为合成层，动画结束提升即消失。

### 6、绘制（重绘）
> 绘制以合成层为单位，构建完图层树后，渲染引擎会对每个图层进行绘制。

1. 渲染进程的主线程生成绘制列表，包含一系列的绘制指令
2. 交由合成线程将图层分为图块（通常为256x256或512x512大小）
3. 交由栅格化线程池并优先绘制视口附近的图块，栅格化通常会交由GPU来做（该过程叫快速栅格化或GPU栅格化，此时生成的位图保存在GPU中）

### 7、合成
光栅化完成后，结果交由合成线程将所有图层的图片合成为一张图片，之后交由GPU进程将内容写入缓冲区等待显示器展示。（另有一种说法为光栅化线程直接将结果交由GPU进程）

### 0、在构建DOM树之前发生的操作
1. 渲染进程的合成线程接收Vsync信号，表示这一帧开始。
2. 合成线程接收用户的交互输入（如触摸/点击/滚动），并交由主线程，在一帧中多次接收相同事件也只会提交一次。
3. 处理requestAnimationFrame提交的任务。
4. 如果访问了需要重新计算的几何信息，则触发强制重排
之后开始构建DOM树以及之后的流程


