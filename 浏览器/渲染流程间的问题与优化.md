# 渲染流程间的问题与解决

### HTML的渲染被阻塞
* JS的加载、解析、执行会阻塞DOM的构建。这是为了避免渲染过程中JS修改DOM导致不一致，所以GUI渲染线程和JS引擎线程是互斥的。
* 同时CSS的加载构建也会间接阻塞DOM的构建，因为JS可以更改CSSOM，而不完整的CSSOM无法使用，所以JS必须等待CSSOM构建完毕，然后才能执行JS，最后再继续构建DOM

### 重排和重绘
* 重排：当修改了页面元素的尺寸/位置，删除添加内容。重排一定会导致重绘的发生。
* 重绘：当元素样式的修改不影响其在文档流的位置，也不影响尺寸，那么只会触发重绘。
* 强制重排：浏览器维护了一个队列收集重排/重绘操作，并在任务数量或时间间隔到达阈值时清空队列，进行一次批处理，从而避免过频繁的重排和重绘。当访问宽高，computedStyle等一些需要重新计算的属性的时候，这时会触发强制重排，从而立即清空队列，这是为了在读取这些值的时候能获得最精确的值。

### 如何减少回流和重绘
* 样式集中修改：使用class替换/cssText来一次性替换多个css值（主要针对旧版浏览器，新版会自动使用队列收集任务进行批处理）
* 离线改变dom：当处理多次DOM修改时，可以考虑使被修改的元素脱离文档流，修改完后再回到文档流，这样只会在脱离/返回时触发重排重绘。
  * 修改过程中隐藏元素。
  * 使用DocumentFragment构建子树并进行修改，之后添加回去。
  * 拷贝原始节点修改后替换原节点。
* 分离读写操作：对于会引起强制重排的属性，将读和写操作分离。
* 缓存布局信息：使用变量缓存可能引起强制重排的属性，类似于读写分离。
* 使用requestAnimationFrame处理动画，在一帧中批处理动画的属性修改
* 使用transform动画，可以将节点提升为合成层，享受GPU加速；并且transform动画在光栅化之后的合成步骤中进行，避免了重排重绘。
* 将节点提升为合成层可以避免重排重绘引起其他层的重排重绘。
* position属性为absolute或fixed的元素，重排开销比较小。

### defer和async
> 用于script标签进行异步加载
* 不使用时，JS的加载执行会阻塞渲染
* defer：遇到JS先加载，加载时不阻塞渲染。等渲染完毕后，根据defer脚本的先后顺序执行。DOMContentLoaded事件在defer脚本执行完毕后才会触发。
* async：遇到JS先加载，加载时不阻塞渲染，加载完毕立刻执行并且阻塞渲染。
* 现代浏览器有一个预解析线程会提前下载外部资源。

### preload和prefetch
> 用于link标签预加载
* preload：指明资源是在页面加载完成后即刻需要的，需提前下载。通过as标识资源类型（as可以为资源设置正确的请求头和内容安全策略，以及加载优先级）
* prefetch：指明资源将会被用到，但不是立刻需要，可能是其他页面需要。浏览器会在空闲的时候进行下载缓存。
* 两个属性不能混用，因为会导致重复加载

### 页面生命周期的事件
* DOMContentLoaded：发生在HTML解析完成后触发，包括deferJS脚本执行后触发。
* load：发生在整个页面和外部资源解析执行后触发。
* beforeunload：页面即将被卸载之前触发，可用于询问用户是否离开。
* unload：页面被卸载之后触发。