1、基本类型：
string(1个字符2字节，使用Unicode编码，所以英文和中文字符都是占用2字节)
number(8字节，采用双精度浮点数表表示，即1位符号位+11位指数位+52位小数位)
bigint(支持任意长度整型，使用"n"来表示如const a = 100n;)
boolean(4字节)
null(typeof时返回的是object，原因是typeof会将二进制表示前三位为0的变量认为是object，而null的二进制表示每位都是0)
undefined
symbol(用于创建全局唯一引用)

2、引用类型
除基本类型外的都是引用类型

3、number的表示，64位中1位符号位，11位指数位，52位小数位。
指数位十进制可以表示[0, 2047]，其中全0和全1的情况会用来做特殊表示：
当指数为除去全0/全1的情况，范围修正为[1, 2046]，指数位在该区间时表示规约数，实际的范围要进行1023的偏移，修正为[-1022, 1023]，规约数在计算的时候小数位要加1，所以规约数的计算公式为(-1)^符号位 * 2^指数位 * (1+小数位)
当指数位全为1，小数位全为0时，表示无穷，根据符号位可以表示正负无穷。
当指数位全为1，小数位不全为0时，表示非数字NaN。
当指数位全为0，小数位全为0时，表示0，根据符号位可以表示正负0。
当指数位全为0，小数位不全为0时，表示非规约数，用来表示更接近0的数字。非规约数的指数为偏移量为1022，所以固定为-1022。非规约数在计算的时候小数位不用加1，所以非规约数的计算公式为(-1)^符号位 * 2^-1022 * (0+小数位)

MAX-VALUE：规约数，即符号位为0，指数位十进制表示1023，小数位全为1的情况。即(2^53-1) * 2^(1023-52)
MIN-VALUE：非规约数，即符号位为0，指数位全为0，小数位最后一位为1的情况。即1 * 2^(-1022-52)
MAX-SAFE-INTEGER：规约数，即符号位为0，指数位恰好将小数位化整（52），小数位全为1的情况。即2^53-1
MIN-SAGE-INTEGER：同上，不过符号位为1。即-1 * (2^53-1)

4、存储位置
ECMA5.1在内存定义上非常模糊，没有明确定义区域的划分，以V8的内存分配来看
boolean/null/undefined存储在栈中，可以用32位数据来表示
symbol/bigint/string/object则都是保存在堆中，栈只保存地址引用
number比较特殊，引擎内部将存储的数字分为两种，Smi（代表-2^31~2^31-1的较小整数）和HeapNumber（浮点数及无法32位表示的数），Smi存储在栈中，HeapNumber则是开辟一个新的内存实体用来存储值

*数组如果存储的是相同类型的，那么在会分配连续内存；如果数组包含各种不同类型，则是非连续内存

5、symbol类型
用于代表独一无二的值，可用作对象的属性名（这样能避免字符串冲突）
Symbol(desc)：通常通过调用该函数来创建，其中desc为Symbol的描述，即使相同，所创建的Symbol也不同。
Symbol.for(key)：该方法可以在全局symbol注册表中创建并返回相同key的symbol，而Symbol(desc)创建的symbol并不会登记在全局symbol注册表中。
Symbol.keyFor(symbol)：返回一个symbol在全局symbol注册表中登记的key。
Object.getOwnPropertySymbols(obj)：获取指定对象obj的所有symbol属性名，不包含字符串属性名
Reflect.ownKeys(obj)：返回obj所有类型的属性名，包括字符串和symbol。

6、检测方式
#1、typeof
可以判断基本数据类型number/number/bigint/undefined/string/symbol
可以判断函数，返回function
判断null/对象的时候返回的都是object
#2、instanceof
用于判断构造函数的prototype属性是否出现在对象的原型链中，在对基本类型进行判断的时候，不会自动包装
#3、Object.prototype.toString.call()
返回内容为[object XXX]，XXX为对应类型，可以判断基本类型和一些内置类型（如Math/Array等），XXX是通过对象的内置属性[[class]]来决定的
