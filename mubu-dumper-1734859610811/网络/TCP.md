# TCP
- 3次握手
    - 1、客户端发送TCP报文告知服务端建立请求，标志位为SYN，序号seq=随机数 x，随后客户端进入SYN-SENT阶段。
    - 2、服务端收到后同时返回消息和发送请求，标志位为SYN，ACK，确认号ack=x+1，序号seq=随机数y，随后服务端进入SYN-RCVD阶段
    - 3、客户端收到后，回复服务端，标志位为ACK，确认号ack=y+1。之后客户端进入ESTABLISHED阶段
    - 服务端收到客户端的回复后也进入ESTABLISHED阶段
    - 说明：三次握手确保客户端和服务端的消息能被对方所接收。而第二次握手服务端把应答和请求合并为了一条，降低了传输消耗。
- 4次挥手
    - 1、客户端发送关闭连接请求，标志位为FIN，seq=x，之后进入FIN-WAIT-1阶段，不再发送数据(不包括挥手的数据)。
    - 2、服务端应答，ACK，ack=x+1。随后服务端进入CLOSE-WAIT阶段，服务端准备释放到客户端的连接。客户端收到这条消息后就明确关闭了自己到服务端的连接，客户端进入FIN-WAIT-2阶段。
    - 3、服务端处理好对客户端的数据发送和释放工作，发送关闭连接请求，FIN，seq=y。之后进入LAST-ACK阶段，不在发送数据。
    - 4、客户端应答，ACK，ack=y+1。之后进入TIME-WAIT阶段
    - 服务端收到应答关闭连接，关闭自己到客户端的连接。进入CLOSED阶段
    - 客户端在返回应答的2MSL后关闭连接，进入CLOSED阶段
    - 说明：1、之所以23步骤没有合并，是因为服务端有可能还有业务未结束。2、客户端等待2MSL是为了确保自己的应答服务端能收到，因为假如服务端没收到，会重发第三步骤，如果2MSL还没收到(应答1MSL，服务端重发过来1MSL)，就认为服务端成功收到应答，所以没有发出。3、1MSL代表报文最大生存时间，是任何报文在网络上存在的最长时间
- 序号seq和确认号ack
    - 不仅请求中带有seq和ack信息，客户端和服务端也会记录自己的seq和ack值来确认顺序
    - 服务端到客户端/客户端到服务端的第一次请求序号seq是随机的，之后的请求序号seq都是等于对方的发送过来的ack。（因为对方的ack是根据我们的seq+1得出，所以我们的seq之后会等于发送过来的ack）
    - ack和seq用于验证TCP的请求顺序，因为TCP连接要求请求的完整性，有序性，丢失报文的情况，接收到序号不对的报文都会走对应的处理。所以ack用于验证下一次收到的seq值。（例：服务端收到seq=100的请求，那么服务端的会立刻应答ack=101。那么下次服务端再收到请求，请求里携带的seq不是101就会丢弃(如果已经接收过该序号，会丢弃并再次应答）
- 与UDP区别
    - 1、可靠性：TCP首部通过序号和确认序号维护数据的顺序，并对缺失数据进行重传。UDP无序号，也不确认数据到达。
        - TCP的超时重传机制：在发送数据时会开始计时，而TCP要求每个请求对方都要应答。所以如果超时没收到应答就会重新发送。
    - 2、TCP仅支持1对1传输，而UDP支持n对n传输。
    - 3、连接方面：TCP通过三次握手建立连接，而UDP没有一开始的连接过程（无连接）。
        - 无连接的说明：无连接指的是UDP这个协议并不会为传输记录状态，来保证传输的可靠。每个报文对于UDP协议来说都是独立存在的，无关联的。所以UDP可以实现1对多通信。
        - 有连接的过程：比如TCP需要在客户端和服务端分别记录seq和ack，来确认请求的序号；比如在发送请求后，要开始计时等待回应，避免对方未收到请求。因为需要在客户端和服务端维护额外的信息保证连接可靠，所以面向连接的TCP处理请求必须建立独立的连接（即1对1通信）
        - 对无连接协议来说，每个分组的处理都独立于所有其他分组，而对面向连接的协议来说，协议实现则维护了与后继分组有关的状态信息
    - 4、TCP面向字节流，UDP面向报文。TCP将应用层数据写入缓冲区并分段发送；UDP无缓冲区，应用层数据不进行分段，直接加UDP首部后交给网络层。
    - 5、效率方面：UDP首部8字节开销小，无数据到达确认，传输效率和实时性更好。TCP首部最少20字节，并且分段传输。
- TCP窗口
    - 假如TCP发送一个请求，等到接收方响应请求后才发送下一个请求，那么请求过程会变得很慢，所以有了窗口的概念，在未到达窗口缓存上限时，发送放可以不用等待请求响应，而是继续发送。同时接收方也有一个滑动窗口接收数据，TCP的报文头可以用于记录接收方的剩余可用缓存数，当滑动窗口满了，发送放将不再继续发送。
    - 发送放使用拥塞窗口：拥塞窗口大小是动态增长的，会使用快启动算法和拥塞避免算法进行大小增长
        - 慢开始算法(慢指的是初始值小，初始增长速率反而更大)：开始时设置阀值sshthresh(默认为16个数据段?) ，初始大小为1，每经历一个RTT（往返时间，动态估算而得）就把cwnd增加为之前的2倍（如果增加2倍后超出sshthresh，则限制为sshthresh），到达阀值后采用拥塞避免算法。
        - 拥塞避免算法：每经历一个RTT就把cwnd增加1
        - 一但RTO(超时重传时间，由RTT和重传次数适应计算而得)时间内出现重传，则把快启动门限设置为当前cwnd的一半，把cwnd设置为1重新开始慢开始和拥塞避免，之所以迅速减小窗口容量，是因为发生了拥塞，如果继续发送会导致拥塞情况更糟糕。(RTO = RTT * 2^重传次数，如果重传后收到响应，会重置为RTT)
    - 接收方使用滑动窗口：滑动窗口是为了减小数据报文丢失时，发送放重新调整窗口大小
        - 快重传机制：1、接收方在连续收到数据时会移动滑动窗口，比如发送放连续发送了1,2,3,4,5,6。接收方收到了1,2,4,5,6。那么滑动窗口会移动到3的位置。2、同时在收到4,5,6时会响应发送方自己未收到3序号的报文。如果发送方收到3次相同序号的丢失响应，就会在超时前进行重传，从而避免超时重传导致的窗口大小调整。3、当接收方收到3号报文，就会回应下一个序号7，代表自己已经收到了4,5,6，下一个只要从7开始发送就行了，同时滑动窗口起始值会移动到7的位置。
        - 快恢复算法：当发生了快重传时（即收到3个序号相同的丢失响应，重新传递该序号报文），此时发送方的拥塞窗口不会调整为1，而是把cwnd和sshthresh都调整为当前cwnd的一半，然后采用拥塞避免算法进行增长。
- 其他
    - TCP首部记录了，确认号，序列号，源端口，目的端口，窗口大小，窗口可使用空间，校验和，数据偏移(表示首部长度)