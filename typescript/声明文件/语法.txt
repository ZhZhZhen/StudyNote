1、declare namespace
#1用来描述一个全局对象：在namespace中可以直接声明函数，变量，类型，枚举等来表示这个全局对象的属性
#2表示嵌套关系：如果对象拥有多层级，命名空间可以表示这种层级关系。比如a.b.c()即为命名空间a下的命名空间b下的一个函数c
#3防止命名冲突：声明文件中的interface和type写在哪里都可以(因为运行时不存在类型，所以编译后类型代码会被删除，因此写哪都不影响运行使用)。但最好写在命名空间下，这样相关的代码可以联系起来，并且避免全局的命名冲突
#4用于声明合并：如果一个对象有多个身份(比如同时是函数和对象)，可以使用命名空间达到声明合并的效果

#旧版namespace是用于内部模块的，es6模块出现后不再推荐使用，现在只用于声明文件中，并且也不需要export关键字来公开自己内部的字段

2、declare fucntion
用于声明一个全局函数的类型，同时支持重载
在声明重载的时候越通用的重载应该放置于后面，因为ts从上到下检测，遇到符合的声明即使用该重载

3、interface和type
直接使用用于声明一个全局的接口或类型，但一般会置于namespace下用于防止命名冲突和关联功能一致的代码
#类型声明在运行期不存在，因此类型代码会在编译后删除，所以类型声明写在命名空间下还是写在全局都不会影响运行时期的使用

4、declare class
用于声明一个全局类，在类中可以定义属性，函数，构造方法等，但不能做具体的函数实现

5、declare var/let/const
var和let声明一个全局变量，(但var会被认为是全局对象的属性(window，global))
const用于声明常量

6、declare enum
声明一个全局枚举
#声明的枚举成员如果没有值，则被认为是计算生成。(而不是0或基于上一个数值成员递增1)

7、直接扩展全局变量
如通过srcipt标签加载一个文件，并给字符串对象添加了一个新方法
声明方式(以给字符串添加方法为例)：在声明文件中直接使用interface String{}，然后在花括号中增加想为String添加的方法

**************************下面是针对模块的语法***********************************
为模块编写声明语法
为第三方库编写：在node_modules/@types/libname下根据原有的库的文件结构创建对应的声明文件，并在其中使用下述语法编写，然后依据DefinitelyTyped(github上)说明进行操作
为第三方库编写(不外用)：直接在源代码根目录下创建.d.ts文件，使用declare module 'libname'{}创建区域，并在花括号中使用下述语法进行编写

8、export
用于描述模块的声明文件，当一个声明文件存在顶级export时，此时该声明文件会变为模块声明文件，并且声明文件名即为模块名，此时文件中的declare不再视为全局声明，必须导出当作模块内容使用(比如declare声明一个方法，再export这个方法。这等同于直接export一个方法)
#1、使用方式和写ts文件的模块导出一致，只是不需要做具体实现
#2、export default：支持默认导出语法。这里有个特殊问题，即默认导出虽然和commonjs中直接赋值exports对象的行为很像，但不兼容，因此必须在tsconfig开启esModuleInterop:true，才能工作。少数情况下不能开启这个配置，这个时候可以先使用declare声明想要默认导出的内容，然后使用export=关键字进行赋值。(export=关键字必须配合import = require语法进行导入，并且export=时其余的导出声明须通过namespace的声明合并的方式实现。这两个语法使用情况很少，推荐直接使用默认导出配合esModuleInterop配置)
#3、export namespace：改语法用于声明一个模块中要导出的具有子属性的对象，也支持多个namespace嵌套
#4、不支持默认导出的变量：只有function/class/interface支持默认导出，对于一个不支持的变量(如枚举)，可以先declare定义，再对其使用默认导出

9、export as namespace
专门为UMD库提供的语法，UMD库指的是既可以当作全局对象使用，又可以当作模块引入的库
声明方式：先在模块中使用export语法进行内容的导出(作为模块)，再使用export as namespace xxx声明全局对象(xxx作为全局对象)

10、declare global
声明模块对全局变量的影响(与直接扩展全局变量不同，这要求导入模块，然后模块对全局变量产生影响)
声明方式(以给字符串添加方法为例)：1、使用declare global{}，并在花括号中增加interface String{}，在花括号中增加想要给String添加的方法。2、如果该模块没有其他模块导出内容，使用export{}做一个空导出，将当前文件标记为模块声明文件

11、export module(模块插件)
声明一个模块对另一个模块的影响(模块插件)
声明方式：1、在模块声明文件中使用import导入原有模块。2、使用export module "原模块名" {}声明内容，并在花括号中添加新增内容

12、declare module
用于在一个声明文件中声明多个模块
#使用declare module xxx{}来声明模块，并在花括号中添加内容。这样做文件名不再是模块，而是xxx作为对应的模块名。
#declare module xxx也可以快速声明一个模块(这里没有花括号)，这样导入该模块的内容被认为是any
#declare module xxx{}支持模块名的通配符
如把所有png文件当作模块进行导入，并在导入时识别为字符串
declare module '*.png' {
  const value: string;
  export default value;
}

13、三斜杠指令
用于声明文件中对全局模块的依赖，因为全局模块没法使用import导入，所以通过三斜杠指令表示依赖关系，并获取其声明文件的类型
编写全局库的声明文件(比如编写全局库声明文件依赖UMD库)，或依赖一个全局库的声明文件时，使用三斜杠指令，否则使用import模块语法。
#三斜杠在旧版本中用于表示命名空间的依赖关系，但现在和命名空间一样不推荐使用，并且只在声明文件中使用

