typescript的类型是基于结构判断的，因此只要结构上一致，就可以是相同类型。(可引申至继承)
判断类型是否兼容最通用的标准就是，以目标类型来使用源类型，如果不会出错，则目标类型兼容源类型

1、对于类型
父类型兼容子类型，而子类型不兼容父类型

2、对于函数
#1、参数数量不同
如果函数类型a的参数列表，函数类型b都兼容(b可以有额外的参数)，则b兼容a
#2、参数类型不同
如果函数类型a的参数(父)和函数类型b(子)的参数具有父子类型。则a和b互相兼容(这是不健全的，但允许)
上述当开启strictFunctionTypes，则b兼容a，a不兼容b
#3、可选参数和rest参数
当函数类型a相比于b含有多余的可选参数，则a和b互相兼容
rest参数相当于数量无限的可选参数(这是不健全的，但允许)
#4、重载函数
需要源函数，和目标所有的重载函数都兼容，才可以兼容
实际上重载函数在typescript只是多个签名+1个实现的函数。因此只要和实现的函数进行比较是兼容的就行

3、对于枚举
当枚举中含有数字成员时，则该枚举和枚举中所列的数字兼容。比如一个枚举含有1，2，4成员，那么可以直接使用这些数字进行赋值。

4、对于类
类的兼容性和类型类似，但是类只比较实例类型，不比较静态类型和构造方法
#private成员和protected成员
除public属性，类a必须拥有来自类b的private/protected成员，b才能兼容a。这其实只有父子关系的类才能满足(不同继承结构的类，即使有同名的private/protected成员也不行)

5、对于泛型
#1、当泛型指定具体类型时，以具体的类型结构进行判断
比如一个空内容的泛型接口，无论使用何种泛型都可以互相兼容，因为其泛型并没有影响到结构
#2、当泛型没有指定类型时，以any来填充泛型并进行比较

6、对于基本类型
任何类型都兼容自己
never：不兼容任意类型，可被任意类型兼容
any：兼容任意类型，除never外被任意类型兼容
unknown：兼容任意类型，除any外不被任意类型兼容
