# Binder
- 使用原因：
    - 1、1次拷贝。 用户端将数据拷贝至内核Binder的缓冲空间，由于该空间与服务端Binder空间有映射关系，所以直接影响到服务端
    - 2、通过binder驱动维护UID/PID，保证安全性(其他跨进程方式需要使用者拟定协议维护uid/pid)，可以建立匿名通道，无法被猜测访问(如socket遍历ip即可访问，所以不安全)
    - 3、高效c/s模式实现的跨进程方式。(socket也是c/s模式，但是主要用于网络和进程间低速通信；管道和消息队列使用存储转发模式，需要两次拷贝)
- 实现*
    - 服务端先通过binder驱动，在内核空间中创建自己的binder实体节点和Binder引用，这里记录的binder的实体(ptr)。
    - 之后服务端通过0号句柄向ServiceManager注册自身字符串标记和客户端引用(handle)的映射关系（0号句柄(描述符是int值，为0)为默认的ServiceManager的客户端引用。向ServiceManager获取服务端引用的过程也是一个跨进程调用）
    - 客户端首先通过0号句柄向使用字符串标记向ServiceManager获取服务端的引用(handle)。之后通过该引用去调用服务端的对应方法发送数据包。
    - binder驱动会负责数据包的发送，主要结构为binder_transaction_data，客户端使用handle，服务端使用ptr，binder驱动在收发过程中会自动转化handle和ptr引用并交给对应端
- Binder中的角色
    - 1、Binder驱动：工作于内核态提供mmap(提供内存映射),ioctl(提供读写)等操作。负责Binder引用的管理/Binder在进程间的传输/数据包的传递
    - 2、ServiceManager(SM)：将字符串表示转为Client对Binder的引用。通过命令BINDER_SET_CONTEXT_MGR将某个进程创建为SM，其他进程可以通过0号引用对他进行跨进程访问。SM维护一个监听Server的死循环，并且维护持有Server句柄(handle)的svclist
    - 3、Client：实现抽象接口的方法，提供对远程函数调用的包装，将函数参数打包，向Server发送请求等待返回值。Client主要通过SM获取Binder引用
    - 4、Server：实现抽象接口的方法，提供具体的服务，通过onTransact()来做数据包的分析，调用相应的接口方法处理请求。Server通过SM注册字符串表示和Binder引用的映射关系
- 用于跨进程传输的数据包 binder_transaction_data
    - code，代表对应的函数索引
    - buffer，存放跨进程方法的参数，和binder的引用
    - offsets和offsets_size，两个参数组合成一个数组，用于标记在buffer中binder的引用位置
    - target.handle和target.prt，前者用于客户端进程对binder的引用，后者为对服务端binder的真正引用。二者在传输中用于找到binder的实体（因为客户端进程和服务端进程只能通过内核空间共享一部分数据，所以客户端是无法直接拿到服务端的binder引用的，
    - handle引用相当于对内核空间的binder的一个标记，驱动通过该标记寻找真正的服务端引用ptr）
    - buffer域中，binder以flat_binder_object的结构存在
- 一次拷贝
    - 接收的进程使用mmap()函数在内核空间创建了一块映射区域，而发送进程只要把数据从自己的缓冲区拷贝到映射区域就行了
    - 拷贝的数据是binder_transaction_data的buffer和offsets部分。而其余的读写消息数据，由于内容是固定长度，所以这部分还是进行两次拷贝，也就是发送进程的用户空间拷贝至内核空间，再拷贝至接收进程的用户空间，这是由于定长的消息使用的缓冲区是可估计的(buffer部分的长度是不可估计的)，所以不需要分配尽可能大的空间（未知的才要尽可能大，这也是两次拷贝的缺点）
- binder的数据包接收队列和线程等待队列
    - 1、每个进程全局的数据包接收队列，用于存放暂未处理的数据包（当线程数到达最大值时）
    - 2、每个进程全局的线程等待队列，用于等待数据包的线程（存放空闲线程）
    - 3、线程私有的数据包接收队列，用于处理等待返回的数据包（比如进程A的线程1处理了进程B的线程2的同步交互，要返回数据就必须返回给线程1的私有数据包队列）
    - 4、线程私有的线程等待队列，用于处理私有的数据包中的数据，但是由于是每个线程私有的，其实队列中只有那一个线程
    - 5、Binder实体节点的异步交互队列，由驱动为其开辟（Binder节点的async_todo域），因为同步交互需要等待返回数据(异步交互发出数据包后交互即结束)，所以需要更快的处理。因此当Binder的任意一条数据包接收队列含有异步交互/线程正在处理异步交互时，异步交互会被发往该队列(而同步交互不收限制直接发给数据包等待队列)。这也表明了数据包接收队列中最多只会存在一条异步交互。
    - 解释：异步交互和同步交互：异步交互发送数据包后，即交互结束；同步交互发送数据包后，还要等待对方的数据包返回
- 其他
    - binder线程池最大线程数为16
    - 受Binder映射缓冲区的大小限制，Intent不能传递内存过大的数据。1、手动mmap()开辟映射时，正常为4M，异步调用(oneway)为2M。2、系统在Native层ProcessState限制大小(比如使用Activity的Intent传输数据就是系统帮我们做的)正常1M-8k，异步调用为(1M-8k)/2(系统产生的这两个空间同一个进程中共享)。
        - 正常调用和异步调用使用的缓冲空间并不是同一个，所以他们应该互不冲突
        - 为什么减少8k，用于划分一个备份存储区域来使得内核更有效的使用虚拟地址空间
        - 主动申请超过4M大小的空间，会被重新修改为4M。
        - 不建议主动申请，因为App通过Binder与系统服务进行交互，这样做会对当前进行binder调用的APP产生不可估计的影响。即使主动关闭binder驱动，也会导致App与其他系统服务无法进行交互。
    - 对于Service来说。Service.onBind()返回的IBinder，是通过AMS.publishService()传递给AMS的，AMS再通过ConnectionRecord.IServiceConnection.connected()传递给客户端。所以这个Binder是没有注册在ServiceManager中的，属于匿名Binder