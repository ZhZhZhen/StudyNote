# 动画
- View动画
    - 对应于Animation的子类，可以完成平移，缩放，选择，透明度动画，可以创建xml帮助生成对应动画；View中与Animation关键字有关的方法都是使用View动画(比如startAnimation())
    - 自定义时，重写applyTransformation()方法，Transformation做变化来达到动画效果（比如改变矩阵，改变透明度）
    - 使用：1、用于Activity的页面切换动画，在finish()，startActivity()后调用overridePendingTrasition()。2、使用LayoutAnimationController(也可以使用xml)来为集合View创建View动画，该动画为View添加/移除时的表现动画。
    - 注意：1、View动画只是改变了View的显示位置(可能和Matrix有关)，所以点击区域不会因为动画而改变。2、帧动画属于View动画，但是实现方式完全不一样
    - 原理：1、第一次调用View.startAnimation()会为View设置Animation，然后调用invalidate()请求重绘。2、每一次VSYN到来，会分发View的工作，在View.draw(三个参数重载)方法中，会通过getAnimation()获取View设置的Animation，然后通过ViewGroup获取Transformation，并调用Animation.getTransformation()对矩阵进行修改，最终矩阵的修改在Animation.applyTransformation()中，之后会根据返回的boolean判断动画是否结束，未结束会再次调用invalidate()。3、之后Transformation的Matrix会用于Canvas的变换，alpha则是设置在renderNode中
- 帧动画
    - 使用AnimationDrawable(或定义drawable中的xml文件)，通过背景的方式来显示
    - AnimationDrawable.ad dFrame()：用于添加Drawable用于播放
    - *动画实现：1、start()会调用setFrame()播放第一帧。2、setFrame()会通过通过selectDrawable()从存储的Drawable数组中取当前帧的Drawable并去触发Cb.invalidateDrawable()绘制重绘(invalidate())，重绘导致draw()方法被调用然后绘制Drawable；3、setFrame()最后会通过Cb来添加回调（Cb.scheduleDrawable()）在下一帧执行nextFrame()，nextFrame()主要是增加frame计数并再次调用setFrame()；4、Callback由View实现，在View设置背景时会向Drawable添加自己给其调用，上述nextFrame()会被View提交给Choreographer来触发更新。
    - 停止动画会维护一些关于动画状态的变量，并调用unscheduleDrawable()移除任务
- 属性动画
    - 通过改变对象属性并重绘来达到动画效果，对应于Animator关键字的类(也可以使用xml)。常用ObjectAnimator（继承至ValueAnimator）、AnimatorSet。
    - ObjectAnimator采用反射去调用setter/getter，通过自身的插值器和估值器计算具体的值，并调用setter，所以对应的setter必须有重绘的逻辑(否则只是改变了值)，getter用于无初始值时获取初始值。
    - ValueAnimator仅仅只是根据时间计算value值，并没有做其他操作，所以想要动画，需要添加AnimatorUpdateListener并在回调中自己根据value处理View。
    - 原理：
        - 在ValueAnimator.start()中，通过addAnimationCallback去注册监听，通过startAnimation()去初始化动画，然后通过setCurrentFraction()去开始第一帧动画
        - startAnimation()：初始化估值器，并且回调监听器的onAnimationStart()
        - setCurrentFration()：计算出时间进度后调用animateValue()来做估值计算
        - addAnimationCallback()：ValueAnimator实现了AnimationFrameCallback接口，将回调添加至AnimationHandler中，之后AnimationHandler会通过Choreographer来注册下一帧时触发的回调，回调会执行doAnimationFrame()去触发注册在AnimationHandler的回调，最终调用ValueAnimation.animateBasedOnTime()->animateValue()
        - 动画的循环：当AnimationHandler注册在Choreographer的监听被回调，会判断自身是否还有观察者，有的话会继续向Choreographer注册下一帧到来时的回调。当动画要暂停时，ValueAnimator会调用AnimationHandler.removeAnimationCallback()，移除自身的监听，如果AnimationHandler发现自身观察者为0则不再向Choreographer注册监听。
        - animateValue()：ValueAnimator类中，该方法会通过插值器计算当前的进度(使用时间进度作为x，求动画百分比进度y)，然后调用估值器(Values)计算具体值，之后回调listener.onAnimationUpdate()；ObjectAnimator类中，还会再次通过反射去调用mTarget的Setter。
        - View.setXXX()：当View的对应setXXX()方法被调用，会通过其成员变量mRenderNode去记录新的修改值，并调用invalidate()。
        - 注意点：1、Choreographer是用于接收显示系统的时间脉冲，所以可以做动画的更新。2、AnimationHandler使用ThreadLocal来实现线程单例，每个AnimationHandler持有Choreographer(也是线程单例)，在向AnimationHandler注册监听或移除监听时，都会判断AnimationHandler自身持有的回调是否大于0，来决定是否要继续向Choreographer注册回调。同样Choreographer在回调之后会移除自身的Callback，所以AnimationHandler在被回调时也会判断是否还有回调而决定是否继续向Choreographer注册回调。
- Choreographer
    - Choreographer用于接收垂直信号Vsync，每次收到信号会取执行输入，动画，traversal。而垂直型号的频率为每秒60帧
    - 所有的输入，动画，travervsal都会通过Callback注册在Choreographer中，对应输入/动画/traversal 三种Callback类型
    - 注册Callback：1、使用postCallback方法向Choreographer注册不同类型的Callback，CallbackQueue是一个链表，会根据Callback的响应时间将他们排序。2、之后会根据Callback的期望触发时间去决定立刻调用scheduleFrameLocked()还是通过Handler发送延时消息调用scheduleFrameLocked()。3、scheduleFrameLocked()判断doFrame()是否完成(根据mFrameScheduled是否为false)，未完成直接返回，否则mFrameScheduled设置为true，然后判断是否使用Vsync信号，使用的话最终会调用scheduleVsyncLocked()请求Vsync信号，不使用信号则直接调用doFrame()。4、收到信号会回调FrameDisplayEventReceiver.onVsync()。然后使用Handler最终执行doFrame()方法。5、doFrame()会计算是否跳帧，然后修正时间，之后把mFrameScheduled设置为false，以便后续第三步操作。然后会依次执行INPUT/ANIMATION/TRAVERSAL三种type的Callback。
    - ViewRootImp.scheduleTraversal()就是向Choreographer注册了TRAVERSAL的callback，来执行performTraversal()从而触发测量布局绘制流程
- 为什么补间动画不能修改移动后的点击位置
    - 补间动画使用ViewGroup的Transformation中的Matrix在draw()方法中做动画的处理。并且所以子View使用的是同一个来自ViewGroup的Matrix。在每次调用draw()的时候，判断父Flag是否要重置该Transformation,需要重置会调用Transformation.clear()。并在动画处理结束后重新设置该Flag为1，所以每个子View使用同一个Transformation并不会影响各自的动画，这只是一个复用降低对象创建的操作。但是由于使用同一个Transformation中的Matrix(而且会被重置)所以无法在触摸时使用逆矩阵去判断View的所在位置是否在触摸范围。(其余猜测：1、View动画中，transformation.matrix也会设置给renderNode，但在View动画结束后会清除。2、也有可能该矩阵不参与mRenderNode.getInverseMatrix()的计算)
    - 属性动画最终会在每一次被调用的时候影响View.setXXX()方法，这个方法会影响View的成员变量mRenderNode。而在判断触摸范围的时候，会通过mRenderNode.getInverseMatrix()获取逆矩阵然后重新修改触摸点位置，再判断View是否在触摸范围。所以可以判断点击位置。