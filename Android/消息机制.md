# 消息机制
- Looper
    - 构造方法： 构造方法会创建MessageQueue
    - prepare()： 是一个静态方法用于使用ThreadLocal创建一个线程持有的Looper
    - loop()：1、用于开启循环通过MessageQueue.next()获取消息，当取到null就会跳出循环。2、当获取到消息就会调用msg.target.dispatchMessage（因为由Looper调用，所以dispatchMessage方法会运行在Looper所在线程）3、回收这个Message至Message的回收池
- MessageQueue
    - euqueueMessage()：消息的发送最终依赖于MessageQueue.enqueueMessage()。1、该方法通过同步方式比较message.when然后加入到链表中。2、在链表为null/当前链头为消息屏障，插入的消息为最先触发的异步消息时会唤醒Looper所在线程。
    - next()：next()写在循环中1、循环的开始根据挂起时间去调用nativePollOnce()挂起线程，挂起时间初始为0，所以第一次循环不会挂起。2、如果发现头结点是一个屏障，则向后一直循环跳过同步消息(屏障本身也是一个同步消息)。3、判断当前节点是否为null，为null等待时间设置为-1；否则判断当前节点Message.when和now，now<when挂起时间=when-now；否则就找到了Message返回出去。4、如果退出状态，则调用dispose()，并返回null。5、统计IdleHandler数量并收集他们，之后依次调用收集的IdleHandler.queueIdle()。并把等待时间设置为0，因为执行IdleHandler的期间可能又添加消息了
        - 每次调用next()只有一次机会去回调IdleHandler。具体做法时初始一个本地变量pendingIdleHandlerCount为-1。当这个值小于0的时候才会去统计IdleHandler的数量并为其赋值。调用完IdleHandler一遍后这个值就会被赋值为0。因为这个时候不再小于0了所以不会再去统计IdleHandler的数量并调用他们了。只有下次调用next()这个本地变量重新为-1的时候才有机会了
        - 第2步到第5步的IdleHandler数量统计收集都在同步块中。IdleHandler.queueIdle()不在同步块中
        - queueIdle()返回值代表运行完后是否保留在IdleHandlers中，返回false就会被移除
    - quit()：当调用Looper.quit()时就会调用该方法，有安全删除和非安全删除，安全删除会保留when<now的消息节点。之后会把mQuitting置为true，这会导致next()返回null
    - *异步消息和同步消息，当使用消息屏障时（无target的Message），MessageQueue.next()不会获取屏障之后的同步消息（循环跳过），而是去获取异步消息并返回。只有通过Handler的构造方法才能创建异步Handler，只有异步Handler才能发送异步消息。
    - 屏障的添加调用MessageQueue.postSyncBarrier()，该方法会创建一个target=null，arg1=barrierToken++（初始为0）的Message，然后在msg.when大于now的Message前插入。并返回token。该token用于移除屏障时寻找该屏障。
    - 线程的挂起和唤醒：挂起调用nativePollOnce()，唤醒调用nativeWake()。调用nativeDestroy()好像会释放线程的挂起唤醒功能需要的一些工作(该方法由dispose()调用，会在finalize()和next()返回null时调用)。
- Handler
    - 构造方法：Handler的构造会获取所在线程的Looper以及Looper持有的MessageQueue。另外还有一个构造方法可以直接持有某一个线程的Looper和MessageQueue。
    - 消息的发送：最终会调用到 Handler.se ndMessage()，会将 指向自己用于回调(这也是造成内存泄漏的原因)，然后调用MesageQueue.enqueueMessage()来添加消息 [msg.target]("http://msg.target")
    - dispatchMessage()：该方法由Looper.loop()取出msg后调用 msg.target .dispatchMessage()时调用，会根据情况回调 ()（即post添加的那个Runnable）或handler.mCallback.handleMessage或handler.handleMessage [msg.callback.run]("http://msg.callback.run")
- 主线程的消息循环
    - 在 ActivityThread.ma in()方法一开始就会创建MainLooper，并在方法结尾开启loop()循环
    - ActivityThread.H是一个Handler，用于处理系统进程通过跨进程调用，进而发送的消息。通常是跨进程调用ApplicationThread的方法，然后由ApplicationThread发送消息，最终通过H调用ActivityThread的方法