# Window
- 使用
    - 通过WindowManager的addView()/removeView()/updateViewLayout()来添加/移除/更新窗口
    - 添加View使用Window.LayoutParams。该lp中，type用于指定Window的层级，层级越高显示越前面(使用系统Window层级在2000~2999，1~99应用Window，1000~1999子Window)；flag用于添加不同的功能属性
- 原理
    - 概念：Window是一个抽象的概念，具体在内存的表现就是顶级View，内存中并不存在具体的Window类(PhoneWindow只是统一管理的一个类)。Window使用WindowManageImpl进行添加/移除，实际工作交给WindowManagerGlobal（是一个单例，会获取进程唯一的WindowSession），在WindowManagerServidce(WMS)中以WindowState进行管理。其中与WMS的交互都依赖于WindowSession，他会在ViewRootImpl创建时，交由ViewRootImpl去跨进程交互。
    - 1.1.1添加过程：使用WindowManagerImpl（WindowManager的最终实现）来进行添加，其内部最终使用的是WindowManagerGlobal来完成添加操作。WindowManagerGlobal会持有WindowSession（该类是用于和WMS进行跨进程调用的proxy类，对应远程端Session），并把WindowSession交由ViewRootImpl，由ViewRootImpl来进行Winodw的创建申请。
    - 1.1.2添加过程的代码调用：1、 WindowManagerImpl.ad dView()。2、 WindowManagerGlobal.ad dView()，该方法内部先创建ViewRootImpl，其构造类会获取WindowSession。然后调用 ViewRootImpl.se tView()。setView()调用后会引用持有ViewRootImpl，View，Lp方便之后获取。3、setView()中先通过 WindowSession.ad dToDisplay()向WMS申请创建，这一步是跨进程调用。之后调用requestLayout触发绘制分发。4、requestLayout()中调用performTranversals()，该方法先回调顶级 View.dispatchAttachedToWindow，之后调用performMeasure()/performLayout()/performDraw()
    - 1.2移除过程：移除使用WindowManagerGlobal.removeView(View)，会通过View获取WindowManagerGlobal中的索引，既而找到对应的ViewRootImp，最终会调用到ViewRootImpl（VRI）.doDie()方法，doDie方法会回调顶级View的dispatchDetachedFromWindow()，并通过WindowSession.finishDrawing()处理移除事务，最后WindowManagerGlobal移除View,VRI,Lp的引用
    - 1.3更新过程：updateViewLayout(View,LP)更新只是取引用的View，更新其Lp，并通过对应的VRI.setLayoutParams()来触发requestLayout()完成绘制。
    - 2.1Activity的添加Window过程：1、在ActivityThread.handleLaunchActivity()->performLaunchActivity()中会创建Activity。2、然后调用 Activity.at tach()方法，该方法中会创建PhoneWindow，并设置回调(比如attachToWindow)。3、在onCreate()中，我们会调用setContentView()，这将调用到PhoneWindow中的同名方法，创建DecorView，并设置content内容。4、在ActivityThread.handleResumeActivity()中，先回调activity.onResume（通过performResumeActivity()），然后会调用 WindowManager.ad dView()，把PhoneWindow创建的DecorView添加至窗口。
    - 2.2Dialog使用：1、构造方法中通过传入的Context。2、在对应生命周期调用setContentView()设置内容。3、使用show()显示
        - Dialog()：构造方法，会根据传递的Context(一般来自于Activity)，获取WindowManager(一般来自Activity)。并创建PhoneWindow（创建的PhoneWindow虽然会调用setWindowManager()创建一个自持有的本地WindowManager，但是不会使用该WindowManager来添加窗口，该PhoneWindow仅仅作为创建DecorView而使用）。
        - show()：1、该方法会会回调Dialog.onCreate()（可以在里面创建Dialog的视图内容）。2、调用PhoneWinodw.getDecorView()获取将要成为窗口的顶层View，调用PhoneWindow.getAttribute()获取WinodwLayoutParams，该lp.type为APPLICATION_TYPE(所以Dialog创建的是一个应用级别的窗口)。3、调用WindowManager.addView(decorView，windowLayoutParams)。需要注意的是这个WindowManger是构造方法中获取的那个来自Activity的WindowManager。
        - *当使用的WindowManager含有PhoneWindow时，在调用WindowManagerGlobal.addView()时会判断PhoneWindow是否为空，不为空会调用其adjustLayoutParamsForSubWindow()来修改WindowLayoutParams中的token。因为Dialog使用的是APPLICATION_TYPE，所以这一步使用的token是来自Activity.attach()时传入的由AMS生成的token。（Activity.makeVisible()请求创建自己的窗口时也是使用这个token，所以Dialog虽然依赖于Activity的token创建，但其实不是子Window）
    - 2.3PopupWindow创建过程：1、在构造方法中或setContentView()方法中会根据传入的View获取Context，再根据该Context获取WindowManager。2、在showAtLocation()方法中会先创建顶层View和Lp，之后通过WM.addView()添加
        - showAtLocation()：1、首先会根据锚点View。调用View.getWindowToken()获取创建Window时需要的token。2、创建WindowLayoutParams，这个lp.type为1000(即子Winodw)。3、创建顶层View，创建的是PopupDecorView，并添加mContentView。4、WindowManager.addView(popupDecorView，lp)，同样该WindowManager其实是Activity的WindowManager
        - 关于showXXX方法在onCreate()返回token null错误原因：1、View.getWindowToken()获取的是AttachInfo.windowToken，而activity.makeVisible()后才会创建ViewRootImpl并在performTraversal()中分发dispatchAttachToWindow()传递AttachInfo。所以在onCreate()到onResume()之间View都是没有AttachInfo的。2、因为使用的是Activity的WindowManager，所以在WindowManagerGlobal.addView()时判断PhoneWinodw不为空，会调用Winodw.adjustLayoutParamsForSubWindow()。这个方法判断token为null，会取PhoneWindow.decorView.getWinodwToken()（即Activity的DecorView，因为使用的WindowManager是Activity的）。同样在没有调用Acitivty.makeVisible()，decorView也是不包含AttachInfo的。所以此时token依然为null
    - 3其余注意点：
        - 1、关于dispatchAttachedToWindow的分发，首先会通过VRL在performTranversals()中调用顶层View分发，而DecorView重写了onAttachedToWindow()方法，该方法中会对自己持有的PhoneWindow.Callback.onAttachToWindow()进行调用，即Activity.onAttachToWindow()，detachedFromWindow方法是类似的。
        - 2、Dialog是应用Window，请求添加窗口时使用的是其依赖的Activity的token，这个token由AMS创建，通过activity.attach()传递Activity；popupWindow是子Winodw，请求窗口使用的是Activtiy.PhoneWinodw.ViewRootImpl.WindowToken。这个token是ViewRootImpl构造函数中new W()赋值而来。
        - 3、Dialog和PopupWindow在使用WindowManager.addView()时使用的都是来自Activity的WindowManager。所以在WindowManagerGlobal.addView()那一步会判断PhoneWindow不为空，既而调用Window.adjustLayoutParamsForSubWindow()。该方法会判断token是否为null，如果为空子窗口会赋值ViewRootImpl的windowToken。应用窗口会赋值mAppToken（这个token就是activity.attach()传递过来的token，在创建Activity的PhoneWindow时会赋值给Window.mAppToken）