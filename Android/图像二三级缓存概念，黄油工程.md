# 图像二三级缓存概念，黄油工程
- 显示的概念
    - 显示中CPU计算帧数据，GPU负责将数据渲染成图像，CPU,GPU(CPU,GPU都需要使用到buffer)把图像数据存在buffer(图像缓冲区)，Display(屏幕)负责把buffer数据显示到屏幕上
    - Display刷新频率为60Hz，取决于硬件固定参数，无法改动，并且逐行的从buffer中取数据从左到右，从上到下，显示一个个像素
    - GPU的帧率是动态的，为了贴合Display，GPU最多每秒可以绘制60帧；但画面静止时，GPU是没有绘制操作的，这时候Display刷新所取的数据是GPU最后操作的那一帧
- 双缓冲概念(为了解决画面撕裂)
    - 撕裂问题：当CPU,GPU把图像写入buffer，Display从buffer读取时，会出现一边修改一边读取，导致画面可能由两帧拼接而成，导致画面撕裂。
    - 解决：使用两个Buffer，一个BackBuffer，一个FrameBuffer。CPU,GPU向BackBuffer写入，Display向FrameBuffer读取。当GPU写入完成时，下一个垂直同步信号（VSync）到来时，BackBuffer和FrameBuffer的引用就会互相交换。(当VSync信号来临时，BackBuffer没写入完成，就不会交换，Display读取的依然是上一帧内容，叫做丢帧。这个时候如果BackBuffer写入完成，只能等到下一个信号来时才能交换，即延时到下一帧显示)
- 黄油工程产生的三级缓冲和Choreographer
    - 针对丢帧处理：如果在VSync信号触发缓存交换后，CPU，GPU立刻向BackBuffer写入(而不是等一会)，这样就尽可能的在下一个信号到来前完成写入。所以产生了Choreographer。
    - 三级缓冲：如果CPU,GPU写入过程超过16.6ms，则依然会导致丢帧。因为CPU/GPU使用同一个Buffer，所以当GPU写入Buffer超过了下一个VSync信号到来时间，CPU也无法开始计算图像数据(一个buffer正在由Display使用，一个正在由GPU使用)。这个时候就需要第三个缓冲空间，让CPU在第三个buffer中开始图像数据计算。GPU写完之前的buffer后，就会去处理CPU刚刚计算使用过的buffer。（使用三级缓存增加了内存消耗，所以未出现丢帧情况的时候，依然是使用二级缓存的）
    - VSync信号：当设备扫描完一个屏幕后，就会从第一行重新开始扫描，这个时候就会发出一个垂直同步信号，该信号用于确认二级缓存互相交换的最佳时间。由于黄油工程，Android4.1之后会在收到信号后立刻开始CPU/GPU的下一帧计算
- Choreographer
    - 简介：使用Choreographer来达到收到VSync信号就立刻开始处理工作的目的。该类用来协调输入，动画，View流程的触发。动画的使用会将每一帧交由Choreographer，等到下一个VSync信号来临时开始运作，同时还可以用该类监控应用帧率。该类使用ThreadLocal记录其线程单例，4.1后默认支持VSync信号接收。
    - 简单理解：Choreographer会将发送的任务存在不同类型队列中(输入，动画，View流程)，然后监听VSync信号，当前VSync到来时会使用Handler发送异步message，当这个message被Looper取出运行时就是将所有类型任务队列的任务执行一遍。
    - View工作流程场景中 ViewRootImpl.scheduleTraversal()：1、会向MainLooper.MessageQueue添加同步屏障，确保Choreographer之后发送的消息能尽快执行（Choreographer发送的是异步消息，所以不受影响）。2、向Choreographer发送了一个Runnable（去调用doTraversal()）该操作会被Choreographer先存储起来。3、Choreographer会注册信号的接收，并在VSync信号到来时，向MainLooper发送消息，这个消息就会执行doFrame()，既而执行刚刚存储的任务。4、doTraversal()会移除同步屏障，然后开始View三大流程。