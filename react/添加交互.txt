1、事件处理函数
事件处理首先是从根dom到目标dom节点的捕获阶段，然后是目标dom节点到根的冒泡阶段。
使用e.stopPropagation()来阻止事件传播。如果在捕获阶段阻止，则冒泡的事件也不会触发。
使用e.preventDefault()来阻止默认的浏览器行为。（如表达提交会自动刷新页面）

2、useState
作用：
	#1、保留每次渲染（如函数组件调用）之间的数据。
	#2、触发React使用新数据渲染组件
Hooks使用时必须在组件或自定义Hook的顶层调用，不能在条件/循环/嵌套函数内调用。这是因为Hooks依托于稳定的调用顺序（分支/循环会打乱顺序）。
React为每个组件保存了一个数组（由React记录，不在组件上），数组成员是一个state对[val, setValFun]。调用useState时会从数组中获取一个state对，并使得访问数组的索引增加（该索引每次渲染前重置）。

3、setState
多次更新state：使用更新函数作为setState()的参数，如setState(n => n+1)
所有的setState操作会被收集在一个队列中，在下次渲染时，队列的函数会被依次执行以获取最新值。
setState(number + 1)本质上可以看作是setState(n => number + 1)的更新函数，只不过忽略了参数n。
更新函数要求为纯函数，在开启严格模式时会执行两次并抛弃第二次结果。

更新对象/数组：避免对原state进行修改，应该把其看作是只读的。在调用setState()时应该创建新对象/新数组。
*使用Immer库可以帮助你通过突变的方式维护state，本质上Immer会根据你的修改从头开始构建下一个state。

在渲染中更新state：在渲染中重新设置自己的state，这会使得React丢弃该组件返回的JSX并立即重新渲染，此时React还未渲染其子组件或更新DOM。为了避免级联重试，React不允许在渲染中更新其他组件的state。

4、state是一个快照
setState()会请求一次新的渲染，每次渲染都会重新创建局部变量和事件处理函数。
使用useState()时，React会为你提供该次渲染的一个state快照。在每次渲染中，对应的快照state是不变的，因此每次渲染中的事件处理函数触发时使用的都是对应渲染的快照state。
*若没有设置新值，则每次渲染（如被父组件触发了嵌套渲染）的快照对象是同一个，所以应该把state认为是只读的，避免对其进行修改。

5、渲染过程
渲染组件指的就是组件函数调用
	#1、触发渲染：初始通过createRoot()创建root，并调用render()触发；后续组件（或祖先）的状态发生改变则触发
	#2、渲染组件：初始渲染会调用根组件；后续渲染React会调用内部状态更新触发了渲染的组件
	#3、提交到DOM：初次React使用appendChild()添加所有创建DOM节点；后续React将应用最少的必要操作（由渲染时计算），以使得DOM与最新的渲染输出相匹配。
	*#4、更新DOM之后，浏览器重新绘制屏幕（浏览器渲染）。

*渲染的过程是递归的，如果更新后的组件返回另外的组件，则React接下来会渲染那个组件，持续到没有更多的嵌套组件。因此默认情况下组件触发渲染，嵌套组件也会跟着被渲染，可以使用一些Hooks进行优化避免子组件的渲染。（组件嵌套渲染有点类似于函数嵌套调用，但其实不是一回事）
*如果渲染结果与上次一致，则React不会修改DOM。