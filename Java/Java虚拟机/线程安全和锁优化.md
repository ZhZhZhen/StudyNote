# 线程安全和锁优化
- *线程安全强弱
    - 不可变：不可变对象一定是线程安全的。如final修饰的字段只要在构建之后就永远不会改变，永远不会看见不一致的状态
    - 绝对线程安全：调用时不用考虑线程安全问题，大部分Java的Api有做线程安全处理的都不是绝对线程安全，因为这是一个很难达到的条件
    - 相对线程安全：通常意义的线程安全，调用时不需要额外保障措施，但是对于特定的连续使用需要额外的同步手段
    - 线程兼容：对象本身不是线程安全的，但是可以通过调用端正确的使用同步来保证对象在并发环境中安全地使用。（个人认为，相对线程安全就是代码有封装对应的同步处理，大部分情况下可以直接使用；线程兼容就是代码没有封装，需要在使用时进行额外的同步处理）
    - 线程对立：无论如何采用同步措施，都无法在并发环境中使用的代码。Java基本很难出现(Thread类的suspend()和resume()方法有可能出现)
- 线程安全的实现方式
    - 互斥同步：重量级操作，悲观锁，线程阻塞和唤醒有较大性能开销
        - synchronized：同步块对同一线程来说是可重入的，在持有锁的线程执行完毕释放锁之前会无条件阻塞后面的线程。优点在于锁能够自动持有，自动释放(相比于重入锁，重入锁需要在final块里主动解锁)
        - 重入锁（ ReentrantLock ）：类库层面实现的互斥同步，优点在于等待可中断，(公平锁)锁可以根据申请时间顺序获得锁，可以绑定多个条件
    - 非阻塞同步：乐观锁，无锁编程，需要操作系统保证其使用的指令为原子操作(如CAS)。
        - 比较并交换CAS：只有当前值和旧值相同，才会使用新值更新。该操作含有ABA问题漏洞，当前值因为多次改变仍等于旧值，依然会更新为新值(大部分情况不影响正确性，有相应的包通过维护变量值的版本来解决该问题)
    - *无同步方案：不需要特殊操作即保证线程安全
        - 可重入代码(纯代码)：比如参数为int a,int b，计算两值相加并返回，这样的方法根本不需要考虑多线程的问题。 如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的
        - 线程本地存储：保证数据的可见范围在一个线程之内。例如使用ThreadLocal存储(每个线程有一个ThreadLocalMap对象，通过数组以hash方式存储，以ThreadLocalHashCode为键，本地线程变量为值，ThreadLocal为该Map集的访问入口)
- 锁优化
    - 编译期优化
        - 锁消除
            - 通过逃逸分析(方法中创建的局部对象是否会被返回出去)来判断，消除不必要的锁。比如说对一段可重入的代码加锁；比如说一些库为了线程安全加了锁，但是在实际使用过程中并不涉及线程安全问题。
        - 锁粗化
            - 降低频繁的加锁和解锁。比如连续的使用同步块，有可能会被优化成一个同步块
    - 自旋锁和自适应自旋锁
        - 使请求锁的线程不立刻阻塞，而是进入一个忙循环，这样避免了挂机和恢复的开销。自适应就是根据之前自旋获得锁的情况来调整自旋次数，如果有可能获得，就会多自旋几次，如果不可能获得，可能会直接进入阻塞(因为如果不可能获得锁，自旋相对于什么事不做白白消耗处理器资源)
        - 轻量级锁发生线程竞争时，竞争失败的那个锁会自旋一段时间重复修改对象头的地址指向自己的轻量级锁(如果重复自旋依然没有修改成功就会变成重量级锁了)
    - 轻量级锁
        - 不能代替重量级锁，应用于没有多线程竞争下加锁的消耗(因为经验得出，很多时候同步块运行一下就结束了，所以很难出现两个线程竞争的情况。但是出现两个线程竞争的情况，还是得使用重量锁)。
        - 通过对象头来记录锁的信息。通过CAS来记录信息，判断同一时间是否有多个线程在竞争锁，如何更新失败则说明有竞争则升级为重量级锁(这时候获得锁的线程就进入同步，其他线程阻塞)，如果更新成功，则说明获得了轻量级锁
    - 偏向锁
        - 也是用对象头来记录偏向信息，同轻量级锁一样为了消除无竞争情况下的同步消耗。
        - 通过CAS在对象头记录线程ID，更新成功，并且后续相同线程访问则都不需要同步。如果出现了另外一个线程获取这个锁(无论同步块是否在运行)，偏向模式则结束，变为未锁定或轻量级锁(然后有可能再膨胀为重量级锁)
    - 流程(似乎不同JVM实现不同)：1、一开始是无锁状态。2、如果有一个线程尝试获取同步状态，会先成为偏向锁，此时对象头被CAS修改去记录线程ID。3、一但有一个新的线程来获取同步状态（无论是否是竞争），都会升级为轻量级锁，锁的对象头就会被CAS指向为轻量级锁的地址。4、这个时候如果有线程来竞争轻量级锁，首先会尝试自旋CAS修改对象头。5、如果自旋修改失败，则把对象头修改为指向互斥量的地址（Java用Monitor实现）同时进入内核态并进入阻塞。（这个时候一开始获取轻量级锁的线程退出同步后会发现对象头不是轻量级锁的地址，而是互斥量的地址，就会进入内核态唤醒阻塞的线程，再切换回用户态）。所以轻量级锁和自旋操作避免了内核态和用户态的切换。6、如果锁空闲了会被降级为轻量级锁，但不会降级为偏向锁。
- 锁的实现
    - 对于同步块：在遇到字节码操作符monitorEnter，则尝试获取monitor。遇到monitorExit则释放monitor
    - 对于同步方法：判断方法是否有标识符ACC_SYNCHRONIZED，有的话在进入方法前尝试获取monitor，离开方法时释放monitor
    - monitor中主要参数
        - _count：记录当前获取锁的线程的重入数
        - _owner：记录当前获取锁的线程
        - _EntryList：记录被阻塞的线程
        - _WaitSet：记录进入等待状态的线程
- 避免死锁的算法
    - 银行家算法：
        - 维护一个Available表表示可用资源数，维护Allocation[]表示每个进程的当前使用量，维护Request[][cur]表示每个进程的当前需求量，维护Need[]表示每个进程的剩余需求量。
        - 当一个进程申请资源时，会尝试分配资源：1(尝试分配)、如果Request[c1][cur]<=Need[c1]，且Request[c1][cur]<=Available，则尝试分配。分配后Need[c1]相应减少Request[c1][cur]量，Available相应减少Request[c1][cur]量，Allocation[c1]相应增加Request[c1][cur]量。2(对尝试结果检测)、尝试分配后进行安全检测，循环每一个进程，判断进程Finish是否为true，为true则跳过；为false，则判断其Need值是否小于Work（初始等于Available），是的话则Work增加其Allocation量，并将其置为true；如果一直循环可以使得所有进程被标记为true，则说明安全。3(检测安全则分配)、安全则根据尝试的量分配资源，否则取消分配。