# 类虚拟机加载机制
- 类加载时机
    - 一个类的生命周期：加载、验证、准备、解析、初始化、使用、卸载。
        - 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。并且是交叉进行，并不是完全执行完一个才执行另一个
    - 初始化阶段开始的时机(有且只有以下6种)。而加载阶段没有明确要求，加载、验证、准备自然要在初始化阶段开始之前开始。
        - 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时。包括使用new关键字实例化对话、读取或设置一个类型的静态字段(被final修饰除外)、使用类型的静态方法
        - 对类型进行反射调用
        - 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是初始化接口的时候，不一定会初始化其父接口，而是在真正使用到父接口的时候才会初始化。
        - 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类
        - 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
        - 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
        - -----------------------------------------分割-----------------------------------------------------
        - 被动引用1：(被动引用不会触发初始化)通过子类引用父类的静态字段，不会导致子类初始化，静态字段所在的父类会初始化
        - 被动引用2：通过数组定义引用类，不会触发此类的初始化
        - 被动引用3：B类引用A类的常量不会触发A类的初始化，因为常量在编译阶段被存入B类的常量池中，本质没有直接引用到A类
- 类加载过程
    - 加载
        - 完成的三件事：1、通过类的全限定名获取定义此类的二进制字节流。2、 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。3、 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
    - 验证
        - 验证阶段大致上会完成下面四个阶段的检验动作：1、文件格式验证(验证字节码文件结构)。2、元数据验证(验证类，方法，字段的合理性(比如权限，继承关系))。3、字节码验证(验证程序语义，就是方法代码对应的字节码操作符)。4、符号引用验证(解析阶段前触发，验证符号引用是否与相应信息匹配)。
    - 准备
        - 为静态变量分配内存并设置默认零值。
        - 如果是静态常量，则会直接赋予常量值，因为在编译时期已经确认了该值
    - 解析
        - 把符号引用(字面上的标记)转为直接引用(内存中的引用)，在解析的过程中也会对相应的权限，以及引用是否存在做校验(就是验证步骤吧？)
    - 初始化
        - 初始化即执行 <clinit>()方法，该方法 是自动产生的，内容包括类中的静态成员变量和静态代码块，由上到下排列执行(可以提前赋值，之后定义，但不能提前使用)
        - 虚拟机会保证子类clinit调用之前父类的clinit被调用(并不是通过子类clinit调用父类)。但是接口不会这样，父接口只有在真正被使用时才会执行clinit。 接口的实现类在初始化时也一样不会执行接口的clinit 方法。
        - clinit方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 clinit方法。
        - 一个类的clinit方法在多线程环境下，只会有一个线程去clinit，其他的都会等待，并且clinit只会执行一次，执行完毕后其他线程被唤醒也不会执行clinit
- 类加载器
    - 对于任意一个类，都必须由加载它的类加载器和这个类(类名，包路径名)本身一起共同确立其在Java虚拟机中的唯一性。唯一性影响了equals()、Class.instance()、instance of。
    - 双亲委派模型
        - 子类加载器加载一个类时，1、先查找是否已经加载过该类，查找到(调用一个native方法查找)返回。2、否则先交给父类加载，父类加载不了会抛出ClassNotFound错误并被捕获。3、如果父类不能加载再由子类加载。这样的方式帮助定义了加载类的优先级，高优先级的类会交给顶级父类加载器去加载，同时防止了创建同名的类去覆盖系统类的情况
        - 加载器的父子关系由成员变量持有，通过组合方式实现，而非继承
        - 通常的三层加载器
            - 启动类加载器(Bootstrap Class Loader)：由c++实现(其余的类加载器为Java实现)，通过null值(扩展类加载器中parent=null)来代表该加载器。用于加载系统类库
            - 扩展类加载器(Extension Class Loader):用于加载系统类库的扩展类库。程序中默认的类加载器
            - 应用程序类加载器(Application Class Loader):用于加载用户类，
        - 自定义加载器：通常重写findClass()，由自己控制如何获取字节码文件对应的二进制流。如果重写loadClass()将会破坏双亲委派模型(因为主要逻辑就是这个方法写的)。
        - 上下文加载器：通过Thread类来设置，用于破坏双亲委派模型，达到由父加载器请求子类加载器的效果