# 基本类型的包装和拆装
- 当基本类型和对应的类进行“==”关键词比较和运算符运算时，类会自动拆箱成基本类型，如
    - Integer == int
    - Integer == (Integer + Integer)   后者计算时拆箱成了int，所以还是类似上面的比较
    - Integer + Integer
    - Integer + int
- 当方法参数为对应基本类型的类时，或该类的父类，或该类的接口，传入基本类型会被自动包装，使用方法为 XXX.va lueOf()
    - Integer a = 11; 该方式也会自动包装，自动包装都是相当于使用XXX.valueOf();
    - public void test(Integer a);  该方法传入1时，会被自动包装成Integer
- 当Integer,Long使用XXX.valueOf()时，如果在-128~127范围，会返回相应类型的常量引用
    - 使用构造方法不遵循该规则，因为该方法的逻辑是由valueOf(数值)实现(Java代码编写)的，并不是底层实现的原理。（构造方法中也不能把this指向另外一个对象吧）
    - Integer a = new Integer(3); 指向堆中的对象区域
    - Integer b = Integer.va lueOf(3); 指向常量池区域
    - Integer c = Integer.valueOf(128); 指向堆中的对象区域，因为不在常量池维护的范围内