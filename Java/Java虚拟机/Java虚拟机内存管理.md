# Java虚拟机内存管理
- 分为线程共享区(方法区，堆)和线程独占区(虚拟机栈，本地方法栈，程序计数器)
    - 独占区域：
        - 程序计数器：当前线程的行号指示器(指示分支，循环，跳转，异常处理)，未规定OOM情况。执行Java方法时记录正在执行的虚拟字节码指令地址；执行native方法时，值为undefined
        - 虚拟机栈(栈)：生命周期与线程相同。描述Java方法执行的动态内存模型。每个方法执行创建一个栈帧，用于存储局部变量表（存放编译期可知的基本数据类型，引用类型，大小在编译期确定），方法相关信息。有可能产生SOF和OOM异常。
        - 本地方法栈：为虚拟机执行的native方法服务，与虚拟机栈类似
    - 共享区域：
        - Java堆：java虚拟机最大的存储区域，存放对象实例和数组，垃圾收集器的主要区域。其中含有部分区域为线程私有的分配缓冲区。可能产生OOM异常
        - 方法区（静态区）：存储虚拟机加载的类信息(类的版本，字段，方法，接口)，常量，静态常量，即时编译的代码。（别名“非堆”，其实是堆的一个逻辑部分）可能产生OOM异常
            - 常量池：类加载后放到会将编译器生成的字面量和符号引用存入该部分，常量不一定要求只是编译期产生，如String类的intern()可以动态添加常量池
            - java7中 静态变量，常量池移至堆 ； java8中方法等信息被移至metaSpace（元空间）。这 只是实现方式变了， 逻辑上存在方法区概念， 原来部分虚拟机采用永久代存储，后采用上述两种方法
- 对象的创建
    - 根据new的参数在常量池中定位一个类的符号引用，并检测所代表的类是否被加载、解析、初始化过，无则进行类的加载、解析、初始化。
    - 在堆中为对象分配内存
        - 2种方式：指针碰撞和空闲列表，根据垃圾回收机制进行选择(由回收导致空间是否规整，规整的话会使用指针碰撞)，为了保证分配时线程安全，有可能采用a.同步(CAS和失败重试法)或b.使用本地线程分配缓冲区(在分配缓存区满后，才使用同步)
        - 指针碰撞：如果有压缩整理时使用，内存被分为用过的和空闲的，通过一个指针作为分界点，分配内存即移动指针。
        - 空闲列表：通过一个列表记录哪些内存块有用，在分配时在列表中找到一块足够大的空间给划给对象实例，然后更新列表记录(个人认为会产生碎片空间，所以区别于压缩整理)
    - 将分配的内存化为零值(不包括对象头)，这一步为了不赋予初始值就可以使用，其实就是赋予初始的零值
    - 对对象（哪个类的实例、如何找到元数据信息、哈希码(实际在延后调用hashCode()方法时计算)、GC分代年龄、是否启用偏向锁）进行设置，并存放于对象头中
    - 调用对象的init方法(构造方法)（init方法内容：1、super()方法。2、成员变量定义根据从上到下执行。3、构造方法中除了super()的剩余代码）
- 对象的内存布局
    - 对象在堆内存的存储布局分为三：对象头、实例数据、对齐填充
    - 对象头：分为两类信息，第一类用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳，这部分在32位和64位中分别战32bit和64bit；第二类为类型指针，指向类型元数据，来确定是哪个类的事例(不是所有虚拟机都这样)；如果对象是一个Java数组，对象头还包括数组的长度，因为此时无法通过元信息判断大小，所以额外记录
    - 实例数据：存放我们程序代码中定义的各类型的字段内容，顺序受虚拟机分配策略参数(FieldAllocationStyle参数)和字段定义顺序影响。HotSpot中顺序为long/double、int、short/char、byte/boolean，该前提下，父类字段先于子类，可以看出相同宽度被分配在一起存放(操作系统的对齐？)
    - 对齐填充：HotSpot虚拟机要求对象起始地址为8字节整数倍，对象头已经满足，所以实例数据如果不满足则需要填充来补全。
- 对象的访问定位
    - 主流方式为使用句柄和直接指针。HotSpot虚拟机主要使用直接指针，大范围来看使用句柄
    - 句柄访问：堆中划分出一块内存作为句柄池，reference类型存储句柄地址，句柄中又包含实例对象地址和类型数据的地址。优点在于对象移动时只需要修改句柄池的引用。
    - 直接指针：reference直接存储实例对象地址，而类型数据地址需要考虑如何放置(如放在实例对象中)。优点在于如果只是为了访问实例，可以减少一次指针定位