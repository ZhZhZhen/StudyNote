# 高效并发
- 硬件的效率与一致性
    - 通过在处理器加入高速缓存，来解决与内存交互时的效率问题
    - 通过一些协议来保证不同处理器高速缓存的读写一致性
    - 乱序执行来充分利用处理器运算单元
- 主存和工作内存
    - Java内存模型定义各种变量访问规则，即关注虚拟机把变量值存储到内存和从内存取出这样的底层细节，这里的变量包括实例字段，静态字段构成数组对象的元素，不包括局部变量和方法参数
    - 上述变量存储在主内存中，而线程的工作内存保存被该线程使用变量的主内存副本，线程对变量的读写需要在工作线程中进行，不能直接访问主内存，不同线程之间也无法直接访问对方工作内存的变量。程序运行主要访问工作内存(比如对对象的实例数据访问，其实是对其在工作线程的副本进行访问)
    - 对应关系
        - 主内存：对应内存区域的Java堆中对象实例数据部分；对应物理硬件的内存
        - 工作内存：对应虚拟机栈的部分区域；为了获取更好的运行速度优先存储于寄存器和高速缓存中
    - volatile关键字
        - 具有可见性，但对其操作无原子性的保证
            - 可见性：每次工作内存使用值都会从主存获取，每次工作内存得到结算结果都会刷新至主存
            - 因为对其操作并没有特殊的限定，所以无法保证对其计算的原子性
        - 禁止指令重排序优化
            - volatile指令 会在汇编中的必要部位加入一个lock前缀的指令(做了一次0偏移的地址移动)，这个指令相当于一个内存屏障（对应4种屏障StoreStore,StoreLoad,LoadLoad,LoadStore，前两个位于V写前后，后两个位于V读前后）
            - 1、内存屏障前的指令不会因为重排而到内存屏障后，反之依然
            - 2、遇到内存屏障时，会将工作内存的修改立刻写入主存。（StoreLoad屏障的语意，所以该屏障开销较大）
            - 3、如果是写操作，会使得其他线程的工作内存中对该变量的缓冲失效，因此他们必须重新从主存读取
    - long和double的特殊规则
        - 非原子性协定：内存模型对64位没有被volatile修饰的数据的读写放宽要求，不一定要保证其读写的原子性
        - *但是主流虚拟机操作是原子性的，32位虚拟机也有额外的专门处理浮点数据的浮点计算器
        - 没有明确的线程竞争，一般不用将long和double修饰为volatile
    - 原子性、可见性、有序性
        - 原子性
            - 基本数据的读写访问(例外的非原子性协定发生意外情况很低)
            - synchronized之间的操作
        - 可见性：即线程修改共享值，其他线程可以立刻得知。
            - 使用volatile修饰的变量。
            - 使用final修饰的变量，使用final修饰的变量在构造器中一旦被初始化，并且构造器没有把this引用传递出去，那么其他线程就能看见final的值，因为不会再被修改，所以可知
            - 使用synchronized，因为对变量执行unlock操作前，必须先把该变量同步至主内存中，所以当别的线程可访问时，主存的值已经是同步后的最新值
        - 有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的
            - 使用volatile修饰，利用其禁止重排序的语义
            - 使用synchronized，因为一个变量在同一时刻只允许一条线程对其lock，所以synchronized之间的代码线程只能串行进行(所以另一个线程观察不到中间状态)
        - 虽然synchronized满足所有性质，但是会使用到互斥来实现，所以不能滥用
    - 先行发生原则
        - a先行发生于b，并不是指时间先发生，而是说a的影响能被b观察到（影响包括，修改了内存中的共享变量的值、发送了消息、调用了方法）
        - 先行发生原则用来判断两个操作ab是否满足，a先行于b，即a的影响能否被b观察到，以此判断是否冲突。（如果观察不到影响，就有可能发生冲突）
        - 先行发生的不一定时间上就先发生，时间上先发生的也不一定先行发生，时间顺序和先行发生原则之间基本没有关系，考虑并发问题应该以先行发生原则为依据
        - 8个判断原则
            - 程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。·
            - 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。·
            - volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。
            - ·线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。
            - ·线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。·
            - 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。·
            - 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
            - 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。
    - Java的线程
        - 线程实现方式
            - 内核线程实现：又称1:1实现，内核线程由操作系统内核支持，内核通过操纵调度器对线程调度，并负责将任务映射到处理器。内核线程对应于一个轻量级进程（线程）用来被程序所使用。优点在于被阻塞时不会影响整个进程，缺点在于操作系统需要在用户态和内核态之间切换
            - 用户线程实现：又称1:N实现，建立在用户空间的线程库上，系统内核不能感知。优点在于不使用内核，避免了用户态和内核态的切换，所以高效且能支持规模更大的线程数量。缺点在于需要考虑阻塞和调度问题，甚至不能实现某些功能
            - 混合实现：又称N:M实现，内核线程和用户线程一起使用。由操作系统支持轻量级进程作为用户线程和内核线程的桥梁
        - Java线程实现方式
            - 实现方式不受约束。1.2前基于绿色线程(用户线程)，1.3起主流平台的虚拟机为1:1线程模型
        - 线程调度方式：抢占式，协同式
            - 协同式：线程执行时间由线程控制，执行完毕后才通知系统切换到另一个线程。缺点在线程执行时间不可控制，可能会出现一直阻塞的问题。
            - 抢占式：线程由系统分配执行时间，切换不由自身决定。系统可以杀死一个执行时间过长的线程或取消等待时间过程的线程。
        - 线程状态
            - 新建（New）:创建后尚未启动的线程
            - 可运行（Runnable）:包括Running和Ready状态，可能在执行也可能在等待操作系统为它分配时间
            - 无限期等待(Waiting)：该状态下线程不会被线程分配处理器执行时间，需要被其他线程显式唤醒
            - 限期等待（Timed Waiting）: 该状态下线程不会被线程分配处理器执行时间 ，可以被其他线程显式唤醒，也可以在一定时间之后由系统自动唤醒
            - 阻塞（Blocked）:线程被阻塞了，阻塞相当于被动进入暂停的状态，而前两个相对于主动进入暂停状态
            - 结束（Terminated）： 已终止线程的线程状态，线程已经结束执行。