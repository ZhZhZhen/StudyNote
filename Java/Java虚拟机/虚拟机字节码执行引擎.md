# 虚拟机字节码执行引擎
- 运行时栈帧结构
    - 每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
    - 每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中
    - 局部变量表
        - 用于存放方法参数、方法内部定义的局部变量、实例方法隐含的this(占用槽0的位置)、try-catch中的Exception
        - 容量以变量槽为单位，该单位编译时就计算好，实际内存消耗由32/64位决定。当一个槽存储一个变量时(如一个boolean),通常不需要32位，这时候会留白补齐来保证一个槽存对应一个数据。另外long/double占2个变量槽
        - *局部变量槽的复用，用于减少空间消耗。
    - 操作数栈
        - 32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2
        - *栈帧可能因为优化而和另一个栈帧有部分区域重叠
    - 动态连接：指向运行时常量池中该栈帧所属方法的引用，主要用于如方法重写是判断调用子类还是父类方法
    - 方法返回地址
        - 用于记录正常方法退出时的主调方法位置。(非正常退出是通过异常处理表来确定地址)
        - 退出时发生的操作： 恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
    - 附加信息：一些帮助调试、性能收集的信息，取决于虚拟机的实现
- 方法调用：确定被调用的方法版本(重写，重载)
    - 解析：在类加载的解析阶段就确立方法的直接引用
        - 能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”
    - 分派
        - 静态分派：根据静态类型决定方法的调用，在编译器就确定了调用的结果(因为静态类型在编译阶段可以直接看到)，如方法重载，所以这部分分派某些书中被归为解析一类
        - 动态分派：根据动态类型来确定方法的调用，如方法重写。
            - invokevirtual指令在虚拟机中会先找到对象的实际类型，根据继承从下到上直到找到目标方法的符号引用，进行权限校验后返回直接引用。没找到或权限校验失败则返回相应异常
            - 这种方法由invokevirtual语义产生，所以对字段是无效的，即字段不参与多态
            - *虚方法表：为了优化动态分派的运行时查找效率。该 表中存放各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。具有相同签名的方法，父子类对应的虚方法表具有相同索引序号来帮助查找
        - 单分派和多分派
            - 方法的接收者和方法的参数统称方法的宗量，根据宗量来判断是单分派还是多分派
            - 目前Java语言是一门静态多分派、动态单分派的语言
- *动态类型支持
    - 为了支持使用Java虚拟机的动态语言。增加了字节码指令 invokedynamic
    - java.lang.in voke可以通过句柄（MethodHandle）实现直接调用某方法的行为。相比于反射，使用句柄更轻。反射是模拟Java代码层次的方法调用，而句柄是模拟字节码层次的方法调用。句柄只记录方法的相关信息，而反射记录方法的属性、描述符、方法属性表各种属性的java端表示。
- 基于栈的字节码解锁执行引擎
    - 解释执行和编译执行
        - 解释执行：运行时解释成操作集来执行
        - 编译执行：直接编译成机器码，然后拿去运行
        - Java取决于虚拟机实现，不过都是先编译成中间文件字节码，而字节码有可能会被解释执行，也有可能通过热点优化来编译成机器码运行
    - 基于栈(操作数栈)、基于寄存器
        - 基于栈的指令集：依赖操作数栈工作，指令不带参数，比如Java的字节码操作符。
            - 优点：不依赖寄存器，所以可移植；不依赖参数的指令更紧凑简洁。
            - 缺点：执行速度慢于基于寄存器的指令；由于出入栈消耗大量指令，完成一个功能需要的指令会更多；频繁的内存访问使得执行速度慢(我猜测运算是在机器上做的，所以要从内存读取，所以寄存器没有这方面的消耗)
        - 基于寄存器的指令集：依赖寄存器工作，指令带参数，比如PC硬件的指令集架构