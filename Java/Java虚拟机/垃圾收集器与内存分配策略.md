# 垃圾收集器与内存分配策略
- 堆的收集方法
    - 引用计数法：有一个地方引用计数+1，引用失效计数-1，计数为零的对象被认为不被使用。该方法需要考虑很多特殊情况，如循环使用
    - 可达性分析法：通过一系列成为GC Roots的根对象作为起始节点，从这些节点向下搜索，走过路径为引用链，如果某个对象没有引用链相连，则认为不可再使用。Java1.2以后、C#使用该方法
- Java中可作为GC Roots的对象
    - 虚拟机栈引用的对象
    - 方法区中静态属性引用的对象
    - 方法区中常量池引用对象
    - 本地方法栈JNI(Native方法)引用的对象
    - 所有被同步锁持有的对象
    - 正在运行的线程对象
    - *Java虚拟机内部的引用，如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器
    - *反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
    - *还有根据实际情况临时加入的对象
- 引用的强软弱虚
    - 强引用：普通概念上的引用
    - 软引用：内存溢出前进行回收，如果此次回收内存仍不足，会抛出OOM
    - 弱引用：垃圾收集时，便会回收
    - 虚引用：不影响对象本身生存时间，也无法通过虚引用获得对象，只用于对象被收集器回收时收到一个系统通知(对象被回收时，虚引用会被加入到一个队列，该队列在创建虚应用时加入)
- finalize()方法
    - 对象被回收时被标记第一次，当该方法被重写且没有被调用过时，该对象会进入F-QUEUE，稍后由低优先级的Finalizer线程执行finalize()方法(不一定保证该方法运行至结束，比如发生死循环，或执行时间过长)，稍后收集器会对F-QUEUE的对象进行第二次标记，如果执行了finalize()方法，且在该方法中将自己引向GC Roots，则第二次会将它移出即将回收的集合。
    - 不推荐使用该方法，会导致程序状态进入不确定中，该方法不等于C语言的析构，是为了让C程序员接受Java而做出的妥协。
- 方法区的收集
    - 主要回收废弃的常量和不再使用的类型，方法区的收集效率因为苛刻的判定条件，回收成功比较低。
    - 废弃的常量(字符串常量、符号引用)：没有地方使用常量池中对象，且虚拟机没有地方引用时收集，类似于可达性分析法。
    - 不再使用的类型：满足3个条件，1该类及派生子类的所有实例被回收；2该类的类加载器被回收；3该类的 java.lang.Cl ass对象没有被任何地方引用，无法在任何地方通过反射访问。当满足条件时被运行回收而不是绝对回收。在大量使用反射、动态代理、频繁自定义类加载器的地方需要虚拟机具备该功能来保证方法区不会压力过大(大部分情况囿于第二点很难被回收)。
- 垃圾收集
    - 大部分收集算法都基于分代收集理论，对新生代和老年代使用不同的收集方式
        - 分代假说：1、绝大多数对象都是朝生夕死；2、熬过越多次垃圾收集过程的对象越难以消亡；3、跨代引用相对于同代引用来说仅占极少数(由前两条推出)
    - 收集方法
        - 标记-清除算法：先标记要被清除(或要保留)的对象，然后进行回收。缺点是执行效率低，会造成空间碎片化问题。
        - 标记-复制算法：把内存划分为相等两块，每次只使用其中一块，先标记，然后从其中一块把存放对象复制到另外一块。缺点是空间缩小为原来一半
            - 更优化的策略(Appel式回收)：内存区分为1个Eden区和2个Survivor区，每次使用其中一个Survivor和Eden。占满时，将存活对象移至另一个Survior区，通常E:S = 8:1。（这样做是经验认为新生代每次回收会回收98%的对象）当复制所需的Survivor空间不够时（极端情况），将直接移入老年代的内存空间，若老年代也不够会进行Full GC。每次分配新生代对象时会优先分配至Eden区。
            - 复制操作对于存活率高的老年代，要进行多次，所以一般用于新生代的收集。
        - 标记-整理算法：标记后，让所有存活对象都向内存空间一端移动，然后直接清理边界外的内存。缺点是使得回收时的停顿加长
        - 标记清除和标记整理混合使用：先使用标记清除，当内存碎片化程度变高，则使用标记整理
    - 对于跨代引用的解决
        - 比如当要回收新生代时，不仅要遍历GC Roots，还要遍历老年代，因为老年代也有可能使用到了新生代的对象。CMS收集器采用记忆集(卡表)来实现，在老年代维护老年代对新生代的引用，回收新生代时会遍历该记忆集的部分，但是CMS独有的Major GC(老年代回收)则需要遍历所有的新生代，因为没有维护新生代对老年代的引用；G1收集器为了解决每个region之间的引用，不仅维护了老年代region对新生代region的引用，也维护了新生代region对老年代region的引用，并且由于有多个region，使得这个维护成本占了堆内存的10%~20%。
    - 新生代到老年代的过程
        - 假设新生代使用Appel式标记复制算法，初始分配对象会分配至Eden区，如果分配过大对象，会直接进入老年代。在进行Minor  GC时会将存活对象移动至Survivor区，并使对象年龄+1，如果此时存活对象大于Survivor区大小，会直接移入老年代，如果老年代仍不足够 (老年代空间小于新生代对象大小，且小于历次晋升的平均值大小) ，会触发Full GC。进入Survivor区的对象，如果年龄到达规定值会进入老年代，或者进入Survivor区的对象某一年龄n的所有对象所占内存大于Survivor区一半，则大于等于n年龄的对象会被移入老年代。
    - 经典垃圾收集器
        - Serial收集器：新生代；单线程收集；标记复制算法；优点在于占用内存小，多用于客户端。
        - ParNew收集器：新生代：多线程收集；标记复制算法；多用于服务端，除了多线程其他与Serial类似。
        - Parallel Scavenge收集器：新生代：多线程收集；标记复制算法；与ParNew类似，区别在于该收集器更注重吞吐量(每次收集总和时间越小越好)，同时提供了可以选择自适应调节的参数(帮助自适应设置堆空间各分代区域大小，收集目标等)。
        - Serial Old收集器：老年代：单线程收集；标记整理；主要用于客户端使用，如果在服务端下，JDK5之前Parallel Scavenge收集器只能和该收集器搭配使用，或作为CMS收集器失败时的后备方案。
        - Parallel Old收集器：老年代：多线程手机；标记整理；是Parallel Scavenge的老年代版本，解决了JDK5之前PS收集器只能配合Serial Old的尴尬局面(因为Serial Old单线程对服务端延时并不友好)。
        - CMS收集器：老年代；标记清除；由于框架原因只能与Serial和Par New配合使用
            - 清除过程：1、初始标记，标记GC Roots直接关联到的对象，停止用户线程，但耗时短；2、并发标记，从GC Roots的直接关联对象开始遍历(与用户线程并发)，耗时长，但不停止用户线程；3、重新标记：需要停止用户线程，耗时短，因为并发标记是与用户线程并发(且时间较长)的，这一步是为了收集这个过程中额外产生的可回收对象；4、并发清除：清除标记的对象，用于不需要移动，所以可以与用户线程并发进行。其中使用的线程数根据处理器的数量进行计算。
            - 优点：并发收集、低停顿（因为耗时最长的第2步是并发运行的）。
            - 缺点：第2步占用了线程会用户程序变慢（不会停顿）；产生浮动垃圾(由第4步产生的可回收对象，这部分对象只能到下一次收集)；第2步需要额外内存使得老年代需要划分部分区域，当老年代划分的区域不足以进行该次收集会使用后备方案使用Serial Old进行收集，导致停顿变长；使用标记清理导致了碎片控件需要进行一次标记整理，导致停顿变长。
        - G1收集器：基于全堆；对于整个region使用清除，region中存活对象使用复制（复制至另一个Region）
            - 清除过程：1、初始标记，标记GC Roots直接关联对象，耗时短，暂停用户线程；2、并发标记，从GC Roots关联对象进行可达性分析，耗时长，不停止用户线程；3、最终标记，处理并发标记遗留的记录；4、筛选回收，统计Region的数据，根据用户期望停顿时间来选择Region集并回收(先把Region中的存活对象复制到另一个Region，然后把旧Region空间清理)，涉及移动，所以暂停用户线程。
            - 特点：面向服务端，回收目标为整个Java堆(但是仍然基于分代理论)，基于Region实现，回收时会选择最有回收价值(能回收越多垃圾和越短时间)的Region集合进行回收，因为局部回收，所以有较短的停顿时间
            - Region：Java堆被划分为多个Region区域，每个Region又分为新生代Region、老年代Region。其中对于超过Region大小的对象还有一个Humongous Region进行存储，并被当作老年代看待。
            - 缺点：由于每个代有多个Region且都有可能互相引用，所以卡表的维护成本占堆内存的10%~20%，所以需要更大的内存消耗
            - 优点：可指定最大停顿时间（ 如果设置不当(如过小)导致回收速率小于内存分配速率，最终也会引发Full GC进入停顿 ）；根据Region分区，并根据Region收益的动态回收；不产生碎片空间(因为基于Region分配内存，而存活对象采用复制的方法复制到另一个Region上，对于Region的整个回收则采用清除)；大内存的应用会有良好表现(高内存的服务端)