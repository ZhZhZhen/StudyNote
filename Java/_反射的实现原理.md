# *反射的实现原理
- 通过字节码文件中相应的符号引用或属性表解析出相应的字段，方法，类的信息。并把这些信息记录在方法区，而java.lang.Class对象就是访问方法区的入口。而反射就是去操作Class这个对象。
- 比如字节码文件中的属性表如Signature支持了泛型的实际类型获取，MethodParameters支持了对方法参数名的获取，这些都是记录在字节码文件中的信息。
- Class类中通过软引用持有着ReflectionData。当调用对应反射方法时，比如getDeclaredMethod()。会先获取RD类中的缓存，如果未获取到RD的软引用或RD未缓存则会使用native方法去获取。
- 优化
    - 缓存反射获取的对象。对于通过字符串限定名查找的对象会异常的耗时，需要缓存避免重复使用字符串限定名查找
    - 尽量使用非字符串查找的反射方式可以减少很多时间
    - setAccess(true)去关闭安全检测，安全检测也会有消耗
    - 使用ReflectASM库，这个库实际上生成了一个新的类，使用普通的类调用方法的方式来代替反射调用。
- 耗性能的可能原因
    - 反射的参数是object数组，所以这里会有额外的装箱步骤
    - 反射会做更多的权限检测(可以setAccess(true)关闭一些检测)
    - 虚拟机难以对反射的代码做优化
    - 使用字符串查找对应元数据的方式，会有匹配遍历的过程，很耗时间