# 泛型
- 使用：
    - 泛型类：1、泛型声明在类名后；2、使用时，通过实例声明传入泛型实际类型/或继承时传入实际类型；3、可以表明其成员变量，函数参数和返回值的类型。
    - 泛型接口：1、泛型声明在接口名后；2、类实现时，用实际类型填充；3、可以表明其成员变量，函数参数和返回值的类型。
    - 泛型方法：1、方法声明使用，需要在返回类型前面声明；2、用于表明方法的参数或返回值类型，其泛型最终类型由方法的参数决定。3、与泛型类的方法不同的是泛型类的方法不用在返回值前面申明泛型，静态方法只能通过泛型方法声明(因为静态方法可以直接调用，而使用泛型类必须实例化才知道泛型的类型，所以不能通过泛型类的泛型去声明静态方法的参数)。4、泛型方法的泛型还可以用于声明内部类的方法的返回值和参数，虽然很少这么做。
- 泛型通配符：声明变量的时候使用泛型通配符来代替实际类型。用于表明该变量中泛型实际类型的范围
    - 单独使用?，泛型实际类型只能转为Object
    - extends A：代表使用的泛型实际类型都是A或继承A类，因此内部泛型成员能使用A类的方法（因为A以下的类都肯定继承了A的方法），但无法赋值内部泛型成员（因为实际类型是A以下的类型，所以对于传入的对象无法确定传入的实际类型一定是自己父类，所以转型可能会产生问题）
    - super A：代表使用的泛型实际类型都是A或A的父类，因为确定了下边界，所以可以对内部泛型成员赋值A及A的子类对象(因为泛型是A以上的类型，所以A以下的对象不会出现转型失败的问题)。但是获取泛型成员时只能转为Object（因为实际类型的上边界不确定，当获取泛型成员时，只能转为父类Object）
    - 例如
        - 定义Cat extends Anima
        - List<?>：该list只能get()到Object对象
        - List<? extends Animal>：只能get()到Animal及父类对象，不能add()对象
        - List<? super Cat>：只能add()Cat及子类对象，get()只能获取Object对象
- 申明泛型时extends的作用
    - 用于泛型声明：作用在于声明泛型可能使用的范围。 public < T extends Parent> T test1 (int a ){}  表明这个泛型T的范围
- 类型擦除
    - 为何擦除：因为兼容协变数组，避免大范围JVM改动，所以泛型擦除，这个问题在后续的Java计划改动
    - 编译后擦除情况，因此JAVA泛型检测是在编译时做的，运行时因为被擦除了无法感知
        - 无限定范围直接消除：List<String>变为List
        - ?有限定边界的，消除为边界类型：List<? extend String>变为List<String>
    - 导致的问题
        - instanceof 只能和原类型比较 :比如 instanceof List
        - 无法创建泛型类的数组，比如ArrayList<Integer>[] a = new ArrayList<Integer>[5];是不允许的（但是ArrayList[] a = new ArrayList[5]是运行的，因为这边只是把他当一个普通类来使用）。但是依然有解决方法（先通过子类继承泛型类，并让这个子类继承的时候就填入泛型实际类型比如MyList extends ArrayList<Integer>，这样子类就不是一个泛型类，可以用于声明MyList数组）
    - 为什么反射可以获取泛型类型：泛型的结构信息记录在属性表Signature中，反射通过该表获取泛型类型元数据信息。而泛型擦除的是属性表Code的泛型信息，因此查看字节码操作符会看不到泛型信息