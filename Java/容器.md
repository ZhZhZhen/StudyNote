# 容器
- Collection：List和Set的抽象接口，定义了集合的基本操作
- List：用来表示一个列表，元素可以重复，有序，容量自增长，允许null
    - ArrayList：非线程安全，插入删除效率低，检索效率高
        - 容量：如果不设定初始容量默认为10。每次扩充为当前的1.5* n+1
        - 自增长实现：当超出内部的Object[]范围，则根据新容量值创建Object[]数组，并复制原数组元素，然后改变引用至新数组。
        - 删除实现：指定index后的元素都向前copy。（所以插入和删除都伴随大量的复制操作，效率不高）
    - LinkedList：非线程安全，双向循环链表实现，插入删除检索效率根据位置决定，较低
        - 查找和删除：内部维护头结点first和尾节点last，会根据查找位置和链表的大小决定从头结点还是尾节点去查找。所以根据位置效率不同，越靠近头尾节点，速度越快
    - Vector：线程安全，插入删除检索效率同ArrayList(因为实现方式一样)
        - 容量：不设定初始值默认为10，每次扩容如果指定增长数n，则增加n，否则翻倍
- Set：用来表示一个集合，元素不重复，检索效率低，删除和插入效率高(不改变元素位置)，每一个Set都基于对应的Map实现(如HashSet基于HashMap。HashSet内部持有HashMap，key就是Set的元素，而value被一个Object占位着)
    - HashSet：无序，非线程安全，可以允许一个null
        - 存入元素时，通过对象的hashCode值计算hash来决定存储位置。
        - 判断元素相同的两个条件(与)：1、equal()比较相等。2、hash值一样。
    - TreeSet：SortedSet的接口实现，有序(自然排序(默认方式)或定制排序)，不允许null
        - 判断不相同(或)：1、equals()返回false。2、CompareTo()比较没有返回0。
        - 排序需类实现Comparable接口(自然)或使用Comparator接口(定制)；自然排序为升序排序；排序的原理为使用红黑树来插入删除
    - LinkedHashSet：继承HashSet，基于LinkHashMap实现（很呆的是HashSet提供了一个构造方法，专门给LinkHashSet调用，而这个构造方法用LinkHashMap来实例化内部的Map）
        - 通过双重链表维护了插入（未维护访问顺序，因为创建LinkedHashMap调用的构造方法是用于维护插入顺序的，即accessOrder为false）。
- Map：映射接口，里面的元素是key-value的键值对。
    - Hashmap：非线程安全，基于数组和链表实现，自增长，key和value可为null(key会用于调用hash()，当key为null时hash为0)
        - 原理：1、根据key的hashCode计算hash值，然后计算在数组中的位置，查找对应位置是否为null。2、为null创建对应的HashMap.Node存放数据；3、否则判断该头Node是否有同样的hash和key；4、否则判断获取的头节点是否为TreeNode，是的话将数据插入树中；5、否则循环链表，如果没有相同hash和key的话，就使用尾插法插入新数据，当插入新数据使得链表长度为9时则变为红黑树。6、上述345遇到hash和key相等的时候，则替换其value。
            - hash值计算：先调用Object.hashCode()获取对象hash值，然后(hash>>>16)异或hash。也就是高16位保留，低16位等于高16位与原低16位异或值
            - 数组的位置：使用上述计算的hash值，pos = hash & (tab.length -1)
            - 判断相等方式：(Node.hash == hash && ((key = Node.key) == key || key != null && key.equals(Node.key)))    (即判断hash是否相同且key是否相同)
        - 扩容：每次扩容都需要重新计算原有元素的位置，所以耗性能，预知大小并通过构造函数创建可以降低扩容次数。每次扩容桶提升为原来的两倍
        - 快速失败Fail-Fast策略：每次修改HashMap会增加版本号modCount，创建迭代器时会使用这个版本号作为成员变量。迭代过程(next())中都会判断迭代器的版本号和Hashmap的版本号是否相同，不同成抛出ConcurrentModificationException()，来确保线程安全。
        - 变化：JDK8相比于JDK7在resize()的时候。1、对于节点的新位置不再使用hash&(newLength - 1)来计算，而是先通过hash&oldLength是否为0来判断是否要移动(不为0则newPos = oldPos + oldLength)。2、resize()时不再使用头插法，而是使用尾插法（比如以前的A->B在resize()后会变成B->A，而现在resize()后依然是A->B）避免了多线程resize()时形成链环的情况
    - TreeMap：非线程安全，key有序且不为null(因为需要调用key.compare()，但是如果传入了Comparator且实现了null值比较的话是允许的)，红黑树实现
        - key的排序方式同TreeSet。
        - 通过使用Fail-Fast策略处理同步问题。
    - LinkedHashMap：HashMap的子类
        - 额外增加了一个双向链表，把加入的节点连成了一个双向链表(通过LinkedHashMapEntry额外记录了after，before节点)，因此可以获得节点的插入或访问顺序（顺序都是尾节点为最近插入或访问节点）。put()时创建新节点会更新最新插入顺序/调用get()或put()时遇到了相同key的时候会更新最新访问顺序。
        - *构造函数的accessOrder，true为按访问顺序，false为按插入顺序
        - *get()操作中通过afterNodeAccess()来根据accessOrder决定是否把读取的Node重新插入尾节点
        - *重写了HashMap.newNode()方法，创建了一个Entry(该Entry继承至HashMap.Node，额外维护了前驱节点和后继节点)，并将该Entry加入到自己维护的链表中然后返回。(newTreeNode()也被重写增加了加入链表的操作)，该方法维护了最新插入的逻辑
        - *重写了HashMap.afterNodeAccess(Node)，将传入的节点移到链表的尾部。在put()方法中，如果遇到了相同的key，会调用该方法。同时LinkedHashMap.get()也调用了该方法。
    - HashTable
        - 相比于HasnMap：1、线程安全，加了大量synchronized。2、不允许key和value为null。3、hash值直接使用对象.hashCode()。pos计算为(hashCode() & (2^31 - 1)) % tabLength。 4、初始大小11，扩容2*n+1
- Iterator：遍历集合的迭代器，是Collection的父接口，通过返回一个Iterator对象来便利集合
- Arrays和Collections：用于操作数组和集合的两个工具类。也可以返回集合类的线程安全版本(通过装饰器模式对方法加了synchronized)