# 线程池
- 主要处理方式：当线程数小于核心数，则创建核心线程并运行任务；当核心线程满了，则往任务队列添加任务，之后等待线程去获取运行；如果任务队列满了，则创建非核心线程并运行任务。如果超出了最大可使用线程数，任务被拒绝。
- 包提供的线程池
    - FixedThreadPool：核心线程数为n，工作队列容量无限(因为无限，所以启用不到非核心线程)。
    - SingleThreadPool：核心线程数为1，工作队列无限
    - CachedThreadPool：无核心线程，线程总数为MAX_VALUE，队列为SynchonousQueue(该队列不存储内容，线程从中获取任务时会等待一个任务进入；如果一个任务进入时，没有线程，则会新建一个线程去接收)，超时等待时间为60s。用于处理短时间、大量的任务。
- 状态
    - RUNNING：接收新任务或从任务队列获取任务
    - SHUTDOWN：不接受新任务，但是继续获取任务队列的任务，由RUNNING执行shutdown()而来
    - STOP：不结束新任务，不获取任务队列任务，并且中断正在运行的任务，由RUNNING执行shutdownNow()而来
    - TIDYING：所有任务执行完，且任务队列为空，线程池为空，由SHUTDOWN/STOP过渡而来
    - TERMINATED：terminated()方法执行完毕，由TIDYING过渡来
- 实现
    - ctl变量：高3位表示线程池状态，低位表示存活线程数
    - execute：1、如果存活数小于核心线程数，则通过addWorker()创建核心线程并运行该任务；2、如果添加核心线程失败(被另外一个线程先添加了)或大于核心线程数则添加至任务队列，添加成功后会进行检查，如果不处于运行状态，则移除任务，并reject()处理失败情况，如果存活线程数为0，则创建非核心线程(极端情况)；3、之后如果任务队列满了，创建非核心线程运行；4、添加失败(如总线程数满了)则通过reject()处理后续情况
    - addWorker(Runnable, boolean)：创建线程来执行任务，通过boolean判断是否是创建核心线程。1、先通过双循环+CAS的方式维护线程数(外循环判断线程池的状态是否运行添加，内循环维护线程数)。2、如果计数成功，之后通过线程池主锁来同步添加worker并运行Worker内部创建的线程。
        - 添加失败的条件：1、线程池大于等于STOP状态。2、线程池处于Shutdown状态，任务队列不为空，但还有Worker存放的情况（因为SHUTDOWN状态还可以取任务队列的任务运行，如果没有Worker，是允许创建无firstTask的Worker的）
    - runWorker()：Worker内部线程启动时会最终调用该方法。内部维护一个循环，1、该循环取创建Worker时传入的firstTask或通过getTask()从队列中获取任务。2、通过Worker内部成员的锁进行加锁，然后运行任务。当取不到任务(循环条件)，会跳出循环执行processWorkerExit()销毁该Worker
    - getTask()：1、该方法先对线程池状态判断，如果不需要在运行了(如进入终止状态)则返回null，这样Worker就会跳出runWorker()的循环然后终止线程；2、接着判断是否超时，第一次循环会跳过该阶段，如果超时了CAS修改存活线程数，修改成功后返回null让Worker终止，否则重新循环判断；3、最后通过阻塞队列根据超时策略来限时获取任务/无限时获取任务。获取到则返回任务，未获取到则说明超时，下次循环会影响第2步的判断。
        - 线程池状态为SHUTDOWN且任务队列为空/线程池状态大于等于STOP都会返回null
        - 超时判断基于当前存活线程数，和核心线程超时策略判断。如果允许核心线程超时，则存活数>0时就有可能获取任务失败；如果不允许核心线程超时，存活时>核心线程数才有可能获取任务失败
    - shutdown()/shutdownNow()：1、通过线程池主锁同步来执行该操作；2、前者在中断Worker时会对Worker尝试加锁（Worker内部持有着一个锁，尝试是使用tryLock()）(由于runWorker()在执行任务时会加锁，所以加锁失败说明正在执行任务，故不会中断)。后者是直接中断；3、前者置线程池为SHUTDOWN，后者为STOP；4 shutdown()执行后，工作队列的工作依然会被执行完成，而shutdownNow()会清空工作队列，并把清空的工作通过list返回
        - 如何判断线程处于空闲：1、当getTask()，会通过阻塞队列取获取任务，如果在queue.poll()/queue.take()被阻塞挂起就说明处于空闲。2、这两个方法会对当前的线程interrupt做判断。如果发现中断就会抛出中断错误，该中断错误会被捕获，但是在getTask()下一次循环中，就会因为判断当前的线程池状态而返回null（由线程池主动调用interrupt()的中断，肯定是因为要关闭线程池了，所以下一次循环就会判断线程池状态后返回null，如果开发者自己在run()方法中中断线程，那么在抛出中断错误后，向量被重置为false，且被捕获了也不会引发提前退出，下一次循环会继续从阻塞队列取任务。）
    - tryTerminate()：该方法会在shutdown()/shutdownNow()/processWorkerExit()中被调用。1、判断是否运行停止，如果线程池<SHUTDOWN状态，或处于SHUTDOWN状态但任务队列没空，或还有Worker存活，都会直接返回。2、通过线程池主锁进入同步状态，首先置线程池状态为TIDYING，然后执行terminated()方法(开发者自己实现)，最后置线程池为TERMINATED状态。
    - 关于 Worker.run Worker()的锁定：Worker在创建的时候设置state为-1，在runWorker()内部循环前会先进行一次unlock，使-1变为0，这个时候才能进行lock，所以通过state是否>=0来判断是否启动。之后的锁定是用于判断Worker是否在执行任务，shutdown()中如果发现Worker已经被锁定则不会去中断该Worker中的线程。