# ConcurrentHashMap
- 使用Node来存储KV数据，内部是数组+(链表/红黑树)，hash值会经过计算，把计算结果相同的放入相同数组位置并且以链表的形式扩展。
- 该Map计算hash时 = hashcode ^ (hashcode >>> 16) & 7FFFFFFF。所以计算的hash绝对是大于0的，这是因为该Map会使用负数作为特殊Node的hash(比如树根hash-2，迁移节点hasn-1)。
- 如何保证线程安全：在put()操作中，通过循环+原子类操作来确保插入进行。1、当桶的位置为空时，会通过cas去创建新节点，创建成功跳出循环，否则下次循环重新判断。2、当桶的位置不为空，且是一个数据节点(不是迁移节点)，会使用该节点作为锁，然后通过链表或红黑树的方式去进行插入操作。（因为同步使用的锁是桶中的头节点，所以不会使得整个Map进入同步。）
- put()：1、先计算在数组的位置，如果该位置无元素则直接通过CAS方式添加新节点(因为整步都写在循环里里，成功后才break)；2、否则如果遇到的节点hash为-1，则说明在扩容中，则帮助扩容(扩容成功进入下一次循环)；3、否则对该节点加锁，(也就是数组中找到的这个元素)，然后判断该节点是树根还是链表，是树根则向数插入节点，是链表则在链尾插入节点，当链表深度达到9时会被转化成红黑树。4、添加成功后返回旧value(如果遇到相同key的情况)，并通过addCount函数来维护size。
- get()：get()操作没有同步措施，但是Node.value被修饰为volatile可以查看最新修改的值。1、计算hash对应的数组位置，如果数组位置所在节点hash相等且key相等则找到返回value；2、如果hash<0，会调用相应的重写find()方法，-1为迁移标记节点，则去正在复制的新数组找，-2则为树节点，通过红黑色的查找方式查找；3、最后通过链表的方式寻找。
- size()：计算CounterCell数组的值，这里只是循环累加
- addCount()：在put后会调用来维护计数，通过CounterCell[]来记录，可能触发扩容transfer()
- transfer()：扩容时，会循环桶，如果遇到null，则添加hash-1的Node(ForwardingNode)标记正在迁移，如果遇到非空点的Node，则会对其加锁，然后将该Node以及之后的链和树移动到新的桶中，移动完之后会在旧桶的位置替换为ForwardingNode。一些影响容器内容的函数在计算位置时发现数组中被ForwardingNode占据，则会触发helpTransfer()来帮助扩容，之后再进行相应操作(比如先帮助扩容再put())