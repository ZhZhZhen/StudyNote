# 读写锁
- 通过state来维护读写状态，高16位用于维护所有读锁的重入数和，低16位用于维护写重入数
- 公平性：用类似于重入锁的方式通过判断是否为阻塞队列的第二个节点的线程，来阻止新的线程因为首次尝试而获取同步
- 重入实现：写锁通过state低16位来记录线程的重入数，而读锁则通过ThreadLocal在每个线程中通过HoldCount来记录重入数
- *写锁
    - 获取：1、有锁时判断是否是读锁，是读锁返回失败。2、不是读锁判断是否为写锁的相同线程，如果是则增加写重入数；3、无锁时通过CAS修改state，成功则标记当前线程为写锁的线程。其余情况认为获取失败
    - 释放：1、先判断当前线程是否是独占线程，不是抛出错误。2、是独占线程就减少写重入计数，为0时置空标记线程
- *读锁
    - 获取：1、判断独占线程是否为当前线程，不是则失败；独占线程为空或是当前线程，则CAS修改state。2、修改成功后，通过ThreadLocal来维护读重入数。(这里会让state+65536，即让高16位+1)
    - 释放：1、获取线程的中记录的读重入数，即让读重入数-1，当为0时会从ThreadLocal中移除该Hodler。2、然后通过CAS+循环的方式修改state-65536（因为读可共享，所以释放时为了考虑线程安全问题而采用循环+CAS）