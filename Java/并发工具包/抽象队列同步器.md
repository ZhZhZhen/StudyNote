# 抽象队列同步器
- 用于实现锁，内部维护一个阻塞队列，并处理了线程挂起与取消挂起和队列的逻辑。子类自己实现获取同步的条件和释放的条件。
- 获取同步或阻塞等待：
    - acquire()：排他锁的内部实现调用该方法。该方法先通过tryAcquire()(由子类实现)获取同步状态，若获取失败则通过addWaiter()加入阻塞队列，并通过acquireQueued()来自旋竞争同步。
    - acquireShared()：共享锁内部实现调用该方法。先通过tryAcquireShared()(由子类实现)获取同步状态，若返回值小于0则说明获取同步失败，则调用doAcquireShared()(该方法逻辑也是通过addWaiter()创建节点加入阻塞队列，并自旋竞争同步)。
        - 与排他锁的区别在于多加了一个传递机制，当该节点竞争到同步状态，如果tryAcquireShared()返回值>0（=0只能获取同步状态，不会传递唤醒），或前头节点/当前头节点处于传递状态，则会调用releaseShared()去唤醒下一个线程节点
    - 自旋竞争的实现：判断当前节点的前序节点是不是头节点，如果是则通过tryAcquire()/tryAcquireShared()获取同步状态。成功的把自己设置为头节点；如果失败则判断是否要挂起线程，如果前序节点为SIGNAL状态则挂起，不是则把有效前序节点(因为这之前可能有CANCELLED状态的节点需要剔除)设置为SIGNAL。
- addWaiter()：先通过CAS尝试加入一个以当前线程创建的节点，失败则通过enq()方法通过CAS+循环的方式加入节点。如果当前链表为空，会先创建一个节点，然后在加入当前节点
- 释放同步状态：
    - release()：通过tryRelease()(子类实现)释放同步状态，成功后，若节点处于SIGNAL状态则会唤醒下一个有效节点
    - releaseShared()：通过tryReleaseShared()(子类实现)释放同步，成功后通过doRelaseShared()来通过CAS+循环的方式做后续处理(因为共享锁可能有多个同步状态同时释放)。处理SIGNAL状态时唤醒后续节点，其中增加了 PROPAGATE状态用于处理同时释放时的情况，该情况下会在队列下一个节点获取同步状态的时候再通过doReleaseShared()去唤醒线程竞争同步
    - 对于tryRelease()/tryReleaseShared()的返回值：这两个方法由开发者在子类中实现。并通过维护state来维护锁的获取许可，那么返回值有什么用呢。返回值的作用在于当返回true时，release()/releaseShared()会唤醒下一个节点开始竞争锁状态。假如我们都返回true，就会造成下一个节点被唤醒然后又因为竞争失败而被挂起，这样做就会造成而外的唤醒开销，是不必要的。所以必须在正确维护state，可能在下次竞争获取锁后才返回true。
- ConditionObject：AbstractQueuedSynchronizer的内部类，用于等待和唤醒
    - 每一个节点在等待队列中使用nextWaiter去链接下一个节点来形成链表。（而在阻塞队列使用的时next和pre形成链表）
    - await()：1、创建一个新的等待节点加入等待队列链尾，其waitStatus=CONDITION。2、调用fullyRelease()来释放同步状态（释放失败说明没进入同步状态就调用了await()，会抛出错误）。3、循环挂起当前线程，循环跳出条件为判断当前节点是否在阻塞队列中。4、调用acquireQueued()去循环竞争同步状态。
    - signal()：1、先判断是否是独占状态，不是直接丢错（因为同步状态中才能调用signal()，而且共享锁没有等待功能）。2、获取第一个等待节点，将其waitStauts设置为0，然后加入阻塞队列。3、判断是否唤醒线程(如果前节点是SIGNAL就不会唤醒该线程，否则会唤醒让其把他前节点设置为SIGNAL)
- 状态waitStatus：用于标记当前节点的状态来决定是不是在等待队列中，决定是否唤醒下一个节点
    - 每个节点被新加入到阻塞队列时waitStatus=0，当调用release()的时候，只有waitStatus!=0，才能唤醒下一个节点的线程。所以新加入的节点都会在acquireQueued()这个方法中去修改前一个节点的waitStatus为SIGNAL，确保前一个节点为SIGNAL才会安心进入挂起状态。从等待队列重新加入阻塞队列的节点，如果发现前一个节点不为SIGNAL，就会主动唤醒线程(如果前节点为SIGNAL就不会主动唤醒，而是等待release()时让前节点去唤醒)
    - SIGNAL -1：该状态在释放同步状态时，让队列的头结点去唤醒他的下一个有效节点。当自旋竞争同步状态失败时，会标记前一个节点会该状态，标记后下一次自旋若还未获取同步状态则当前线程会被挂起
    - CANCELLED 1：该状态标记节点为弃用状态，多数操作会无视该节点，比如递归获取一个有效节点，这之间的CANCELLED节点被抛弃等。如在允许超时的加锁过程中，如果超时了，那么对应的节点会被标记为CANCELLED节点
    - CONDITION -2：标记该节点进入了等待队列。
    - PROPAGATE -3：用于处理共享锁的锁唤醒情况，因为可能会出现多次releaseShared()(短时间的极端情况)但只唤醒一次线程的情况。针对这种情况，第二次调用releaseShared()会把头结点的ws从0置为PROPAGATE，这样阻塞队列中的节点在竞争到同步状态,调用setHeadAndPropagate()时会检测前头结点/当前头节点ws是否小于0，小于0的话（tryAcquireShared()返回值如果大于0也会）会再调用一次doReleaseShared()去唤醒下一个节点的线程。
- 其他
    - 1、共享接口提供的原因：如果所有的同步状态能按串行的方式解锁，那么排他锁接口也是能实现多个线程进入同步状态的。共享锁接口产生的原因是为了处理多个线程同时解锁的情况。如果使用排他锁面对这种情况就会导致阻塞节点不能被正常唤醒。出现明明可以获取同步状态了，但由于没被唤醒而无法运行下去的情况
    - 2、除了acquire()/acquireShared()，抽象队列同步器还提供了可抛出中断错误的锁获取和超时返回的锁获取，实现逻辑都是差不多，但是增加了中断判断/超时判断。并在中断时抛出错误/超时时返回false