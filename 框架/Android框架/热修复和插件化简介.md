# 热修复和插件化简介
- Tinker
    - 1、反射获取了PathClassLoader中的PathList，反射调用PathList.makeDexElements()并传入patch文件来生成Element[]。
    - 2、反射获取PathList.dexElements，然后将其与自己生成的Elements[]合并，使patch加载而得的Element在数组前面。
    - 3、将合并后的Element[]赋值给pathList.dexElements[]。Android类加载器加载到所需的类就会返回，所以数组前面的Element会覆盖后面的原有的Element类信息
- VirtualApk
    - Activity
        - 1、反射设置了ActivityThread.Instrumentation，将其设置为自己实现的类。
        - 2、当调用startActivity()启动插件Activity时，会调用到自己实现的Instrumentation.execStartActivity()，在该方法中根据启动Activity的类型将其componentName替换为对应的占坑Activity（不同的占坑Activity有不同的启动模式）并记录原来想启动的Activity的信息，然后调用AMS.startActiivty()去跨进程申请启动。
        - 3、当回调到ActivityThread.performLaunchActivtiy时()，会通过Instrumentation.newActivity()创建Activity，使用保存的信息反射创建该Activity。创建该Activity所需要的类信息通过DexClassLoader去加载存储路径的文件。
        - 4、在Instrumentation.callActivityOnCreate中反射修改Activity的域，如修改Resource，baseContext，mApplication，交由自己的类替代。这样多数功能就被代替实现了
    - Service
        - 反射修改了ActivityManagerNative（用于AMS交互的类），替换为动态代理对象
        - 代理对象中对startService，stopService，bindService，unbindService这些方法做了处理。修改Intent为待占坑Service的信息，并保存原Intent。然后统一通过startService()来启动占坑Service。该startService使用的Intent中记录了对应的（bind/unbind/start/stop）操作
        - 当占坑Service.onStartCommand()回调时，根据Intent的信息，使用插件ClassLoader加载插件Service.class并反射实例化，反射调用其attach()方法将需要的类比如Context都替换成插件中的。然后根据保存的Intent信息回调对应生命周期方法
    - BroadcastReceiver
        - 解析Manifest 重新动态注册一遍
    - ContentProvider
        - 反射获取了ActivityThread.mProviderMap中占坑ContentProvider的IContentProvider，并替换了该对象，代理其query等方法。然后把对插件的Uri替换成占坑ContentProvider的uri，插件uri拼接在该uri后面。交由其去远程调用远程的占坑ContentProvider对应方法。
        - 当服务端占坑ContentProvider.query()被调用时，获取Uri信息去加载插件ContentProvider.class并反射实例化，然后把uri重新替换为原来的插件Uri，传递给他，返回其query()的返回值给客户端的占坑IContentProvider
- 其他
    - UnSafe类修改内存中的指针，比如修改方法指针